---
title: "Optional data pruning using a list of species"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

```{r header}

#  ██████╗ ██╗  ██╗██╗   ██╗██╗      ██████╗ ██████╗ ██╗  ██╗███████╗██████╗ ███████╗
#  ██╔══██╗██║  ██║╚██╗ ██╔╝██║     ██╔═══██╗██╔══██╗██║  ██║██╔════╝██╔══██╗██╔════╝
#  ██████╔╝███████║ ╚████╔╝ ██║     ██║   ██║██████╔╝███████║█████╗  ██████╔╝█████╗
#  ██╔═══╝ ██╔══██║  ╚██╔╝  ██║     ██║   ██║██╔═══╝ ██╔══██║██╔══╝  ██╔══██╗██╔══╝
#  ██║     ██║  ██║   ██║   ███████╗╚██████╔╝██║     ██║  ██║███████╗██║  ██║███████╗
#  ╚═╝     ╚═╝  ╚═╝   ╚═╝   ╚══════╝ ╚═════╝ ╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝

## PHYLOPHERE: A Nextflow pipeline including a complete set
## of phylogenetic comparative tools and analyses for Phenome-Genome studies

### Github: https://github.com/nozerorma/caastools/nf-phylophere
### Author: Miguel Ramon (miguel.ramon@upf.edu)

#### File: .data_pruning.Rmd

```

# Optional Data Pruning for Trait Analysis
This document describes the process of optionally pruning the dataset based on a user-provided list of species. 
This step ensures that only specified species are included in subsequent analyses.

Fast and easy.

## Setup and Directory Configuration

This section configures the working environment, sets directories, and loads necessary functions and libraries.

```{r setup, message=TRUE, warning=TRUE}

# Call the setup function from commons.R
source("./obj/commons.R")
setup_rmd()

# Debug helper (prints into HTML output)
if (is.null(getOption("phylo_debug"))) {
  options(phylo_debug = TRUE)
}
if (!exists("phylo_debug_log", envir = .GlobalEnv)) {
  phylo_debug_log <- character()
}
if (!exists("debug_log", inherits = TRUE)) {
  debug_log <- function(...) {
    msg <- sprintf(...)
    phylo_debug_log <<- c(phylo_debug_log, msg)
    cat("[DEBUG] ", msg, "\n", sep = "")
  }
}

# Load necessary libraries
library(dplyr)
library(ggplot2)
library(readr)
library(reshape2)
library(ggrepel)
library(ggtree)
library(ggnewscale)
library(ggstar)
library(colorspace)
library(treeio)
library(tidytree)
library(phylolm)
library(ggtreeExtra)
library(geiger)
library(rphylopic)

color_palette <- paste0(clade_name, "_palette") # Color palette for the clade
capitalized_taxon <- tools::toTitleCase(taxon_of_interest) # Capitalized taxon name
capitalized_trait <- tools::toTitleCase(gsub("_", " ", trait)) # Capitalized and deconvoluted trait name
capitalized_clade <- tools::toTitleCase(gsub("_", " ", clade_name)) # Capitalized and deconvoluted clade name

createDir(data_pruning_dir)

# Create subdirectories for the new plots

extreme_plots_dir <- file.path(data_pruning_dir, "1.Extreme_plots")
asr_trees <- file.path(data_pruning_dir, "2.ASR_trees")
phylo_distribution_dir <- file.path(data_pruning_dir, "3.Phylo_distribution")

createDir(extreme_plots_dir)
createDir(asr_trees)
createDir(phylo_distribution_dir)

```
## Data Pruning Process
This section loads the prune list, prunes the trait data frame and phylogenetic tree, and saves the pruned data for downstream analyses.
```{r set_ourdirs, message=TRUE, warning=TRUE}

prune_list <- get_arg(args, 13, "")
prune_list_secondary <- get_arg(args, 14, "")

print(paste("Prune list primary:", prune_list))
print(paste("Prune list secondary:", prune_list_secondary))

# Load the prune list
if (prune_list != "") {
  prune_species_primary <- readLines(prune_list)
  cat("Loaded prune list with", length(prune_species_primary), "species\n")
} else {
  stop("No prune list provided. Please provide a valid list of species to prune.")
}

# Optional secondary prune list (e.g., for secondary trait)
if (prune_list_secondary != "") {
  prune_species_secondary <- readLines(prune_list_secondary)
  cat("Loaded secondary prune list with", length(prune_species_secondary), "species\n")
}

# Generate stats_df
stats_df <- stats.f(trait_df)

# Cleanup data frame and tree
`%ni%` <- Negate(`%in%`)

pruned_trait_df <- trait_df[trait_df$species %ni% prune_species_primary, ]
clean_tree <- ape::drop.tip(pruned_tree, prune_species_primary)
pruned_stats <- stats_df[stats_df$species %ni% prune_species_primary, ]

cat("Pruned trait data frame has", nrow(pruned_trait_df), "species\n")
cat("Pruned tree has", length(clean_tree$tip.label), "species\n")
cat("Pruned stats data frame has", nrow(pruned_stats), "species\n")

# Save pruned data
pruned_trait_file <- file.path(data_pruning_dir, "pruned_trait_file.tsv")
write.table(pruned_trait_df, file = pruned_trait_file, sep = "\t", row.names = FALSE, quote = FALSE)
pruned_tree_file <- file.path(data_pruning_dir, "pruned_tree_file.nwk")
ape::write.tree(clean_tree, file = pruned_tree_file)
pruned_stats_file <- file.path(data_pruning_dir, "pruned_trait_stats.csv")
write.csv(pruned_stats, file = pruned_stats_file, row.names = FALSE)

# Nullify trait values for downstream plots (do not affect emitted pruned files)
nulled_trait_df <- trait_df
nulled_stats_df <- stats_df

if (length(prune_species_primary) > 0 && trait %in% names(nulled_trait_df)) {
  nulled_trait_df[nulled_trait_df$species %in% prune_species_primary, trait] <- NA
  nulled_stats_df[nulled_stats_df$species %in% prune_species_primary, trait] <- NA
  cat("Nulled primary trait for", sum(nulled_trait_df$species %in% prune_species_primary), "species\n")
}

if (length(prune_species_secondary) > 0 && nzchar(secondary_trait) && secondary_trait %in% names(nulled_trait_df)) {
  nulled_trait_df[nulled_trait_df$species %in% prune_species_secondary, secondary_trait] <- NA
  nulled_stats_df[nulled_stats_df$species %in% prune_species_secondary, secondary_trait] <- NA
  cat("Nulled secondary trait for", sum(nulled_trait_df$species %in% prune_species_secondary), "species\n")
}

# Rename the variables for downstream use (plots use nulled data, tree stays pruned)
trait_df <- nulled_trait_df
stats_df <- nulled_stats_df

# Save files for debug
debug_log("Data pruning completed. Pruned trait file: %s, Pruned tree file: %s", pruned_trait_file, pruned_tree_file)
write.csv(stats_df, file = file.path(data_pruning_dir, "debug_pruned_stats.csv"), row.names = FALSE)
write.csv(trait_df, file = file.path(data_pruning_dir, "debug_pruned_trait_df.csv"), row.names = FALSE)

```

# Rebuild figures

## 1. Load Melted Trait Data
This section loads pre-processed trait data in a long (melted) format and adds common names for species.

```{r, stat_visualization, message=TRUE, warning=TRUE}

# 1. LOAD STATS ------------------------------------------------------
# Excerpt of the trait stats data
head(stats_df)

stats_df <- stats_df %>%
  dplyr::mutate(
    value = .data[[trait]],
    taxa = .data[[taxon_of_interest]],
    common_name = gsub("_", " ", species)
  )

if(isTRUE(has.n)){
  stats_df <- stats_df %>%   
    mutate(N = .data[[n_trait]])
  debug_log("contrast_plot.f using n_trait = %s, missing N = %d", n_trait, sum(is.na(stats_df$N)))
}

# Ensure species order matches phylogeny
ordered_species <-  tidytree::as_tibble(pruned_tree) %>%
  dplyr::arrange(desc(.data$node)) %>%
  # Remove internal nodes by filtering only rows where label is not NA
  dplyr::filter(!is.na(.data$label)) %>%
  dplyr::pull(.data$label)

print(ordered_species)

stats_df$species <- factor(stats_df$species, levels = ordered_species)
debug_log("contrast_plot.f ordered_species = %d", length(ordered_species))

# Define ordered taxa for plotting based on phylogeny order
ordered_taxa <- ordered_species %>%
  sapply(function(sp) {
    idx <- which(stats_df$species == sp)
    if (length(idx) == 0) return(NA_character_)
    stats_df$taxa[idx[1]]
  }) %>%
  unname() %>%
  na.omit() %>%
  unique()

print(ordered_taxa)

# Arrange stats_df by taxa
stats_df <- stats_df %>%
  dplyr::mutate(taxa = factor(taxa, levels = ordered_taxa)) %>%
  dplyr::arrange(taxa, .by_group = TRUE)

```

# 3. Contrast Plots
This section generates contrast plots to visualize the trait across taxa, highlighting extreme values and outliers.

```{r phenoplot, fig.height=10, fig.width=15, message=TRUE, warning=TRUE, dev='png', dpi=320}

## PLOT FUNCTION --------------------------------------------------------------
### 1. Contrast plot function
contrast_plot.f <- function(df) {
  stopifnot(all(c("species", taxon_of_interest, trait) %in% names(df)))
  palette_values <- get_palette_values()
  debug_log("contrast_plot.f rows = %d, trait = %s, taxon = %s", nrow(df), trait, taxon_of_interest)
  debug_log("contrast_plot.f columns: %s", paste(names(df), collapse = ", "))
  fill_scale <- if (is.null(palette_values)) {
    ggplot2::scale_fill_discrete()
  } else {
    ggplot2::scale_fill_manual(values = palette_values)
  }
  color_scale <- if (is.null(palette_values)) {
    ggplot2::scale_color_discrete()
  } else {
    ggplot2::scale_color_manual(values = palette_values)
  }

  global_median <- df$g_median
  
  ggplot(df, aes(x = value, y = taxa)) +
    ggplot2::scale_y_discrete(limits = rev(ordered_taxa)) +
    ggplot2::geom_point(
      data = subset(df, global_label == "normal"),
      aes(shape = global_label, color = taxa), size = 5
    ) +
    ggplot2::geom_point(
      data = subset(df, global_label %in% c("low_extreme", "high_extreme")),
      aes(shape = global_label, color = taxa, fill = taxa), size = 5
    ) +
    ggplot2::scale_shape_manual(values = c("low_extreme" = 15, "normal" = 1, "high_extreme" = 17)) +
    ggplot2::scale_fill_manual(values = palette_values, breaks = 0) +
    ggplot2::scale_color_manual(values = palette_values, breaks = 0) +
    ggplot2::geom_vline(xintercept = global_median, linetype = "longdash", linewidth = 1.2, color = "salmon3") +
    ggplot2::stat_summary(fun = median, geom = "errorbar",
                          aes(xmax = after_stat(x), xmin = after_stat(x), y = taxa),
                          linewidth = 1.2, color = "skyblue4", alpha = 0.8) +
    ggplot2::labs(x = capitalized_trait, 
                  y = paste(capitalized_taxon, "-", capitalized_clade), 
                  title = paste("Trait differential plot for trait:", capitalized_trait, "in", clade_name),
                  caption = "Global median shown as a longdash red line. Per taxa median shown as skyblue error bars. 
                  Extreme values were identified based on global thresholds (top and bottom quantiles).") +
    ggrepel::geom_text_repel(
      data = subset(df, global_label %in% c("low_extreme", "high_extreme")),
      aes(label = species), size = 5, hjust = 0, vjust = 0, family = "Inter",
      segment.size = 0.3, nudge_x = 0.010, nudge_y = 0.5, max.overlaps = Inf,
      force = 1, direction = "y", max.iter = 10000, label.padding = 20,
      min.segment.length = 0.06, seed = seed_val, show.legend = FALSE
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      plot.title = ggplot2::element_text(size = 20, hjust = 0.5, margin = ggplot2::margin(t = 20), face = "bold"),
      axis.text.y = ggplot2::element_text(size = 15),
      axis.title.x = ggplot2::element_text(size = 15, hjust = 0.5, margin = ggplot2::margin(t = 20, b = 20)),
      axis.title.y = ggplot2::element_text(size = 15, angle = 90, hjust = 0.5, margin = ggplot2::margin(l = 20, r = 20)),
      caption = ggplot2::element_text(size = 12, hjust = 0.5, margin = ggplot2::margin(t = 20)),
      legend.text = ggplot2::element_text(size = 15),
      legend.position = "bottom"
    )
}

# 3. CONTRAST PLOTS  ------------------------------------------------------
plot_ready <- !is.null(stats_df) && nrow(stats_df) > 0
required_cols <- c("species", taxon_of_interest, trait)
plot_ready <- plot_ready && all(required_cols %in% names(stats_df))

if (!plot_ready) {
  message("Skipping contrast plot: missing or empty trait stats.")
} else {
  contrast_graph <- contrast_plot.f(stats_df)
  ggplot2::ggsave(
    file.path(extreme_plots_dir, paste0(trait, "_contrast_plot.png")),
    contrast_graph, device = "png", width = 15, height = 10, dpi = "retina"
  )
  contrast_graph
}

```

# 4. Violin Plots
This section generates violin plots to show trait distributions across taxa.

```{r violin_plot, fig.height=10, fig.width=8, message=TRUE, warning=TRUE, dev='png', dpi=320}

### PLOT FUNCTION --------------------------------------------------------------
violin_extremes.f <- function(df, trait, taxon_of_interest) {
  stopifnot(all(c("species", taxon_of_interest, trait) %in% names(df)))
  palette_values <- get_palette_values()
  debug_log("violin_extremes.f rows = %d, trait = %s, taxon = %s", nrow(df), trait, taxon_of_interest)
  fill_scale <- if (is.null(palette_values)) {
    ggplot2::scale_fill_discrete()
  } else {
    ggplot2::scale_fill_manual(values = palette_values)
  }
  dark_palette_values <- get_palette_values(paste0("dark_", color_palette))
  fill_scale_dark <- if (is.null(dark_palette_values)) {
    fill_scale
  } else {
    ggplot2::scale_fill_manual(values = dark_palette_values)
  }
  color_scale_dark <- if (is.null(dark_palette_values)) {
    ggplot2::scale_color_discrete()
  } else {
    ggplot2::scale_color_manual(values = dark_palette_values)
  }

  # Ensure species order matches phylogeny
  ordered_species <- pruned_tree$tip.label
  df$species <- factor(df$species, levels = ordered_species)
  debug_log("violin_extremes.f ordered_species = %d", length(ordered_species))
  
  # Define ordered taxa for plotting using global phylogeny order if available
  if (!exists("ordered_taxa", inherits = TRUE) || length(ordered_taxa) == 0) {
    ordered_taxa <- unique(pruned_tree$tip.label %>%
      sapply(function(sp) df$taxa[df$species == sp]) %>%
      na.omit())
    if (length(ordered_taxa) == 0) {
      ordered_taxa <- unique(df$taxa[!is.na(df$taxa)])
    }
  }
  
  # Calculate median value for reference line
  median_value <- median(df$value, na.rm = TRUE)
  
  # Create violin plot
  plot <- ggplot2::ggplot(data = df, aes(x = value, y = taxa)) +
    ggplot2::scale_y_discrete(limits = rev(ordered_taxa)) +
    ggplot2::geom_violin(
      aes(fill = taxa), color = "black", width = 0.5, trim = TRUE, scale = "width", alpha = 0.15
    ) +
    fill_scale_dark +
    ggplot2::geom_point(
      data = subset(df, outlier == "normal"),
      aes(shape = global_label, color = taxa),
      size = 3, position = ggplot2::position_jitter(height = 0.25)
    ) +
    ggplot2::geom_point(
      data = subset(df, outlier != "normal"),
      aes(color = taxa, fill = taxa),
      shape = 21, size = 3, stroke = 0.8, position = ggplot2::position_jitter(height = 0.25)
    ) +
    ggplot2::scale_shape_manual(values = c("low_extreme" = 15, "normal" = 1, "high_extreme" = 17)) +
    color_scale_dark +
    ggplot2::geom_vline(
      aes(xintercept = median_value), linewidth = 1, color = "salmon3", alpha = 0.5
    ) +
    ggplot2::stat_summary(
      fun = median, geom = "errorbar",
      aes(xmax = after_stat(x), xmin = after_stat(x)),
      linewidth = 1.5, color = "black", alpha = 0.6, width = 0.75
    ) +
    ggplot2::labs(x = capitalized_trait) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      axis.text.y = ggplot2::element_text(size = 17, hjust = 0.5, face = "bold"),
      axis.title.x = ggplot2::element_text(size = 17, hjust = 0.5, face = "bold", margin = ggplot2::margin(t = 20, b = 20)),
      axis.title.y = ggplot2::element_blank(),
      legend.text = ggplot2::element_text(size = 15),
      legend.position = "none"
    )
  
  return(plot)
}

if (!plot_ready) {
  message("Skipping violin plot: missing or empty trait stats.")
} else {
  violin_plot_path <- file.path(extreme_plots_dir, paste0(trait, "_violin_plot.png"))
  violin_graph <- violin_extremes.f(stats_df, trait, taxon_of_interest)
  ggplot2::ggsave(
    violin_plot_path,
    violin_graph, device = "png", width = 8, height = 10, dpi = "retina"
  )
  violin_graph
}
  
```

# 5. Ancestral State Reconstruction (ASR) Plots
This section generates ASR plots to visualize the evolutionary history of the trait across the phylogenetic
```{r asr_plot, fig.height=20, fig.width=17, message=TRUE, warning=TRUE, dev='png', dpi=320}

# 4. ASR PLOTS  ------------------------------------------------------
asr_tree.f <- function(df, tree, trait, taxon_of_interest) {
  
  # --- Trait vector ---
  trait_vec <- df[[trait]]
  names(trait_vec) <- df$species
  trait_vec <- trait_vec[!is.na(trait_vec) & is.finite(trait_vec)]
  if(length(trait_vec) < 3) stop("Need >=3 non-missing species.")
  debug_log("asr_tree.f input rows = %d, trait_vec = %d", nrow(df), length(trait_vec))
  

  tree <- ape::drop.tip(tree, setdiff(tree$tip.label, names(trait_vec)))
  tree <- ape::reorder.phylo(tree, "cladewise")
  Ntip <- length(tree$tip.label)
  Nnode <- tree$Nnode
  debug_log("asr_tree.f tree tips after prune = %d, nodes = %d", Ntip, Nnode)
  node_indices <- (Ntip+1):(Ntip+Nnode)

  # Sanitize trait vector to match pruned tree
  trait_vec <- trait_vec[tree$tip.label]

  # Also sanitize the data frame
  df <- df[df$species %in% tree$tip.label, ]
  df$species <- factor(df$species, levels = tree$tip.label)

  debug_log("asr_tree.f trait_vec after prune = %d", length(trait_vec))
  debug_log("asr_tree.f df after prune = %d", nrow(df))
  
  # --- Fit BM / lambda ---
  fit_model <- function(tree, trait, model=c("BM","lambda")) {
    model <- match.arg(model)
    df <- data.frame(trait=trait, species=names(trait))
    fit <- phylolm(trait~1, data=df, phy=tree, model=ifelse(model=="BM","BM","lambda"))
    aic <- fit$aic; k <- fit$p
    aicc <- aic + (2*k*(k+1))/(length(trait)-k-1)
    list(lnL=fit$logLik, sigma2=fit$sigma2, lambda=fit$optpar, aicc=aicc, raw=fit)
  }
  
  fit_bm <- fit_model(tree, trait_vec, "BM")
  fit_lambda <- fit_model(tree, trait_vec, "lambda")
  debug_log("asr_tree.f fit_bm aicc = %.3f, fit_lambda aicc = %.3f", fit_bm$aicc, fit_lambda$aicc)
  
  delta_aicc <- fit_bm$aicc - fit_lambda$aicc
  chosen_model <- ifelse(fit_lambda$aicc < fit_bm$aicc, "lambda", "BM")
  if(abs(delta_aicc)<2 && !is.null(fit_lambda$lambda) && abs(fit_lambda$lambda-1)<0.05) chosen_model <- "BM"
  debug_log("asr_tree.f chosen_model = %s", chosen_model)
  
  # --- Rescale tree & ASR ---
  if(chosen_model=="lambda"){
    lambda_hat <- fit_lambda$lambda
    if (is.null(lambda_hat) || is.na(lambda_hat)) {
      lambda_hat <- 1
    }
    debug_log("asr_tree.f lambda_hat = %.4f", lambda_hat)
    sigma2_used <- fit_lambda$sigma2
    rescaled_tree <- phytools::rescale(tree,"lambda",lambda=lambda_hat)
  } else {
    sigma2_used <- fit_bm$sigma2
    rescaled_tree <- phytools::rescale(tree,"BM")
  }
  debug_log("asr_tree.f sigma2_used = %.6f", sigma2_used)
  
  # Recalculate node_indices for rescaled tree (structure may be same, but let's be safe)
  Ntip_rescaled <- length(rescaled_tree$tip.label)
  Nnode_rescaled <- rescaled_tree$Nnode
  node_indices <- (Ntip_rescaled+1):(Ntip_rescaled+Nnode_rescaled)

  # Get point estimates via ACE with fallback to the original tree
  ace_try <- function(tree_obj) {
    tryCatch(
      ape::ace(x = trait_vec, phy = tree_obj, type = "continuous", method = "REML"),
      error = function(e) tryCatch(
        ape::ace(x = trait_vec, phy = tree_obj, type = "continuous", method = "ML"),
        error = function(e2) NULL
      )
    )
  }
  ace_res <- ace_try(rescaled_tree)
  model_used <- chosen_model
  if (is.null(ace_res)) {
    message("ACE failed on rescaled tree; retrying on original tree.")
    ace_res <- ace_try(tree)
    if (is.null(ace_res)) {
      message("ACE failed on original tree; falling back to fastAnc without CIs.")
      anc_est <- tryCatch(
        phytools::fastAnc(rescaled_tree, trait_vec),
        error = function(e) NULL
      )
      if (is.null(anc_est)) {
        debug_log("asr_tree.f fastAnc failed")
      } else {
        debug_log("asr_tree.f fastAnc ok, n = %d", length(anc_est))
      }
      if (is.null(anc_est)) {
        stop("ACE and fastAnc failed.")
      }
      ace_res <- list(
        ace = anc_est,
        CI95 = cbind(anc_est, anc_est)
      )
    } else {
      rescaled_tree <- tree
      Ntip_rescaled <- length(rescaled_tree$tip.label)
      Nnode_rescaled <- rescaled_tree$Nnode
      node_indices <- (Ntip_rescaled+1):(Ntip_rescaled+Nnode_rescaled)
      model_used <- "BM"
    }
  }
  
  node_est <- ace_res$ace
  tip_est <- trait_vec[rescaled_tree$tip.label]
  debug_log("asr_tree.f node_est = %d, tip_est = %d", length(node_est), length(tip_est))
  
  # --- Build node and tip tables ---
  # Use analytical CIs from ace
  node_ci <- ace_res$CI95
  node_df <- data.frame(
    node = node_indices,
    estimate = as.numeric(node_est[as.character(node_indices)]),
    ci_lower = as.numeric(node_ci[,1]),
    ci_upper = as.numeric(node_ci[,2]),
    stringsAsFactors = FALSE
  )
  # Tips don't have analytical CIs in ace output, use point estimates
  tip_df <- data.frame(
    tip = rescaled_tree$tip.label,
    estimate = as.numeric(tip_est[rescaled_tree$tip.label]),
    ci_lower = as.numeric(tip_est[rescaled_tree$tip.label]),
    ci_upper = as.numeric(tip_est[rescaled_tree$tip.label]),
    immediate_parent = NA,
    cumulative_derived = NA,
    direction = NA,
    parent_node_id = NA,
    parent_ci_lower = NA,
    parent_ci_upper = NA,
    stringsAsFactors = FALSE
  )
  
  # --- Derivedness tests: immediate-parent and cumulative-ancestors ---
  # Build parent map (use rescaled tree dimensions)
  parent_map <- integer(Ntip_rescaled + Nnode_rescaled)
  parent_map[] <- NA_integer_
  for (j in seq_len(nrow(rescaled_tree$edge))) {
    parent_map[rescaled_tree$edge[j,2]] <- rescaled_tree$edge[j,1]
  }
  
  # Test tips for derivedness
  for (i in seq_len(nrow(tip_df))) {
    tip_label <- tip_df$tip[i]
    tip_est_val <- tip_df$estimate[i]
    tip_idx <- which(rescaled_tree$tip.label == tip_label)
    parent_id <- parent_map[tip_idx]
    
    if (!is.na(parent_id)) {
      # Store parent node ID
      tip_df$parent_node_id[i] <- parent_id
      
      # Get parent node CI
      if (parent_id <= Ntip_rescaled) {
        parent_row <- tip_df[tip_df$tip == rescaled_tree$tip.label[parent_id], ]
      } else {
        parent_row <- node_df[node_df$node == parent_id, ]
      }
      parent_ci_low <- parent_row$ci_lower
      parent_ci_high <- parent_row$ci_upper
      
      # Immediate-parent derivedness test
      tip_df$immediate_parent[i] <- (tip_est_val > parent_ci_high) || (tip_est_val < parent_ci_low)
      
      if (tip_est_val > parent_ci_high) {
        tip_df$direction[i] <- "up"
      } else if (tip_est_val < parent_ci_low) {
        tip_df$direction[i] <- "down"
      } else {
        tip_df$direction[i] <- "none"
      }
      
      if (tip_df$immediate_parent[i]) {
        tip_df$parent_ci_lower[i] <- parent_ci_low
        tip_df$parent_ci_upper[i] <- parent_ci_high
      }
    }
    
    # Cumulative derivedness: derived from ALL ancestors
    anc_list <- integer(0)
    cur <- tip_idx
    while (!is.na(parent_map[cur])) {
      cur <- parent_map[cur]
      anc_list <- c(anc_list, cur)
    }
    anc_nodes <- anc_list[anc_list > Ntip_rescaled]
    
    if (length(anc_nodes) == 0) {
      tip_df$cumulative_derived[i] <- FALSE
    } else {
      anc_rows <- node_df[node_df$node %in% anc_nodes, ]
      if (nrow(anc_rows) == 0) {
        tip_df$cumulative_derived[i] <- NA
      } else {
        tip_df$cumulative_derived[i] <- all((tip_est_val > anc_rows$ci_upper) | (tip_est_val < anc_rows$ci_lower))
      }
    }
  }
  
  # --- Plot ---
  cont_obj <- phytools::contMap(rescaled_tree, trait_vec, plot=FALSE)
  debug_log("asr_tree.f contMap range = [%.4f, %.4f]", cont_obj$lims[1], cont_obj$lims[2])
  cont_obj <- phytools::setMap(cont_obj, colors=colorRampPalette(c("white","salmon3"))(100))
  h <- max(phytools::nodeHeights(cont_obj$tree))

  par(mar=c(5,5,10,7), oma=c(0,0,2,0))

  plot(cont_obj, fsize=1.8, lwd=6, res=320, legend=FALSE,
      xlim=c(-0.2*h, 2*h),
      cex.main=2.5)

  lwd_bar <- 10
  root_node_idx <- node_indices[1]
  root_est_str <- sprintf("%.2f (%.2f-%.2f)", 
                          node_df$estimate[1], 
                          node_df$ci_lower[1], 
                          node_df$ci_upper[1])
  
  phytools::add.color.bar(
    Ntip_rescaled - 1, 
    cont_obj$cols, 
    title = paste0(trait, " (", model_used, ")"),
    subtitle = "",
    lims=NULL,
    lwd=lwd_bar, 
    direction="upwards",
    x=-0.2*h, 
    y=1,
    prompt=FALSE, 
    fsize=1.5
  )
  
  # Add ticks and labels to color bar
  tick_x <- -0.2*h + lwd_bar / 20
  lines(x = rep(tick_x, 2), y = c(1, Ntip_rescaled))
  nticks <- 10
  
  Y <- seq(1, Ntip_rescaled, length.out = nticks)
  X <- cbind(rep(tick_x, nticks), rep(tick_x + 0.02*h, nticks))
  ticks <- seq(cont_obj$lims[1], cont_obj$lims[2], length.out = nticks)
  text(x = X[, 2], y = Y, labels = round(ticks, 3), pos = 4, cex = 1.5)
  
  # Add root annotation
  text(x = 0.02*h, y = Ntip_rescaled/1.45, labels = root_est_str, pos = 4, cex = 1.5, col = "black")
  
  # Collect parent nodes that have derived tips
  parent_nodes_with_derived_tips <- unique(tip_df$parent_node_id[tip_df$immediate_parent & !is.na(tip_df$parent_node_id)])
  
  # Add labels ONLY for parent nodes of derived tips
  for (parent_node in parent_nodes_with_derived_tips) {
    if (parent_node > Ntip_rescaled) {
      # It's an internal node
      parent_row <- node_df[node_df$node == parent_node, ]
      if (nrow(parent_row) > 0) {
        parent_est <- parent_row$estimate
        parent_ci_low <- parent_row$ci_lower
        parent_ci_high <- parent_row$ci_upper

        # Create label: estimate (ci_lower-ci_upper)
        parent_label <- sprintf("%.2f (%.2f-%.2f)", parent_est, parent_ci_low, parent_ci_high)

        # Display at the parent node
        ape::nodelabels(text = parent_label, node = parent_node,
                        frame = "none", cex = 1.5, col = "black", adj = c(-0.25, 0.4))
      }
    }
  }
    
  # Add tip symbols and labels
  for(i in seq_len(Ntip_rescaled)){
    tip_pos <- i
    
    if(tip_df$immediate_parent[i]){
      # Tip symbol for derived tips
      pch_val <- ifelse(tip_df$direction[i]=="up", 24, 25)
      bg_val <- ifelse(tip_df$direction[i]=="up", "salmon3", "skyblue3")
      ape::tiplabels(pch=pch_val, bg=bg_val, tip=tip_pos, cex=2, offset=58)
      
      # Tip value (larger to match parent node emphasis)
      ape::tiplabels(text=sprintf("%.2f", tip_df$estimate[i]), 
                    tip=tip_pos, frame="none", cex=1.5, offset=40)
      
      # Connection line from tip to tip value
      segments(x0 = h, y0 = tip_pos-0.4, x1 = h + 70, y1 = tip_pos-0.4, 
              col = "gray50", lty = 2)
    }
    
    # Cumulative derived marker
    if(tip_df$cumulative_derived[i]){
      ape::tiplabels(pch=22, bg="forestgreen", tip=tip_pos, cex=2, offset=62)
    }
  }
  
  mtext(paste0("Symbols: ▲ Tip Up, ▼ Tip Down, ■ Cumulatively derived; ",
              "Parent node values shown for derived tips."),
        side=3, line=-2, cex=1.2, adj=0.35)
  
  
  # --- Return ---
  list(
    chosen_model=chosen_model,
    node_table=node_df,
    tip_table=tip_df,
    sigma2_used=sigma2_used,
    ace=ace_res,
    rescaled_tree=rescaled_tree
  )
}

if (!plot_ready) {
  message("Skipping ASR plot: missing or empty trait stats.")
} else {
  asr_plot_path <- file.path(asr_trees, paste0(trait, "_asr_tree.png"))
  tryCatch(
    {
      grDevices::png(
        filename = asr_plot_path,
        width = 17, height = 20, res = 320, bg = "white", units = "in"
      )
      asr_result <- asr_tree.f(stats_df, pruned_tree, trait, taxon_of_interest)
      grDevices::dev.off()
    },
    error = function(e) {
      message("ASR plot file failed: ", e$message)
      try(grDevices::dev.off(), silent = TRUE)
    }
  )
  tryCatch(
    asr_tree.f(stats_df, pruned_tree, trait, taxon_of_interest),
    error = function(e) message("ASR report plot failed: ", e$message)
  )
}

```

## 6. Fan Plot for Phylogenetic Distribution

This section creates a fan-shaped phylogenetic tree.

```{r visual_distribution, fig.height=15, fig.width=15, dev="png", dpi=320, message=TRUE, warning=TRUE}

# 5. PHYLOGENETIC DISTRIBUTION PLOT  ------------------------------------------------------
palette_values <- get_palette_values()
fill_scale <- if (is.null(palette_values)) {
  ggplot2::scale_fill_discrete()
} else {
  ggplot2::scale_fill_manual(values = palette_values)
}
color_scale <- if (is.null(palette_values)) {
  ggplot2::scale_color_discrete()
} else {
  ggplot2::scale_color_manual(values = palette_values)
}

# Create base phylogenetic tree in fan layout
base_fan_tree <- ggtree(pruned_tree,
                        layout="fan",
                        open.angle=15, 
                        size=2)

ggsave(file.path(phylo_distribution_dir, "big_tree.png"), base_fan_tree, device = "png", width = 15, height = 15, dpi = "retina")

ordered_species <- rev(pruned_tree$tip.label)
row.names(stats_df) <- stats_df$species

# Prepare trait data for tree visualization
tree_trait_data <- stats_df %>%
  group_by(species, taxa)

# Is there a branch color trait specified?
if (isTRUE(has.branch)) {
  tree_trait_data <- tree_trait_data %>%
    mutate(
      br_trait = .data[[branch_trait]]
    )

  # Perform ancestral state reconstruction for LQ trait
  br_trait_vec <- tree_trait_data$br_trait
  names(br_trait_vec) <- tree_trait_data$species
  br_asr_fit <- phytools::fastAnc(pruned_tree, br_trait_vec, vars = TRUE, CI = TRUE)

  # Create data frames for tip and node values
  tip_br_data <- data.frame(
    node = nodeid(pruned_tree, names(br_trait_vec)),
    BR = br_trait_vec
  )
  node_br_data <- data.frame(
    node = names(br_asr_fit$ace), 
    BR = br_asr_fit$ace
  )
  combined_br_data <- rbind(tip_br_data, node_br_data)
  combined_br_data$node <- as.numeric(combined_br_data$node)
}
  
if (isTRUE(has.n) && isTRUE(has.secondary)) { # Now for both has.n and has.secondary TRUE
  tree_trait_data <- tree_trait_data %>%
    dplyr::rename(secondary_value = .data[[secondary_trait]]) %>%
    summarize(
      trait_sum = sum(value, na.rm = TRUE),
      trait_is_na = all(is.na(value)),
      n_sum = sum(N, na.rm = TRUE),
      secondary_sum = sum(secondary_value, na.rm = TRUE),
      secondary_is_na = all(is.na(secondary_value)),
      .groups = "drop"
    ) %>%
    ungroup()
} else if (isTRUE(has.n)) {
  tree_trait_data <- tree_trait_data %>%
    summarize(
      trait_sum = sum(value, na.rm = TRUE),
      trait_is_na = all(is.na(value)),
      p_sum = sum(p, na.rm = TRUE),
      .groups = "drop") %>%
    ungroup()
} else if (isTRUE(has.secondary)) { # If has.secondary are TRUE, we would need to adjust accordingly.
  tree_trait_data <- tree_trait_data %>%
    dplyr::rename(secondary_value = .data[[secondary_trait]]) %>%
    summarize(
      trait_sum = sum(value, na.rm = TRUE),
      trait_is_na = all(is.na(value)),
      secondary_sum = sum(secondary_value, na.rm = TRUE),
      secondary_is_na = all(is.na(secondary_value)),
      .groups = "drop") %>%
    ungroup()
} else { # If neither is TRUE  
  tree_trait_data <- tree_trait_data %>%
    summarize(
      trait_sum = sum(value, na.rm = TRUE),
      trait_is_na = all(is.na(value)),
      .groups = "drop") %>%
    ungroup()
}

tree_trait_data <- tree_trait_data %>%
  mutate(
    trait_sum_plot = ifelse(trait_is_na, 0, trait_sum),
    trait_fill = ifelse(trait_is_na, 0, trait_sum),
    trait_asterisk = ifelse(trait_is_na, "*", "")
  )

if (isTRUE(has.secondary)) {
  tree_trait_data <- tree_trait_data %>%
    mutate(
      secondary_sum_plot = ifelse(secondary_is_na, 0, secondary_sum),
      secondary_fill = ifelse(secondary_is_na, 0, secondary_sum),
      secondary_asterisk = ifelse(secondary_is_na, "*", "")
    )
}

# Convert tree to tibble and join with trait data
tree_tibble <- tidytree::as_tibble(pruned_tree) %>%
  dplyr::rename(species = label)

tree_with_traits <- full_join(tree_tibble, tree_trait_data, by = 'species')

# Again, if branch color trait is present, join that data as well
if (isTRUE(has.branch)) {
  tree_with_traits <- full_join(tree_with_traits, combined_br_data, by = 'node')
}

print(tree_with_traits)

# Export dataframe for debug
write.csv(tree_with_traits, file.path(phylo_distribution_dir, "tree_with_traits.csv"), row.names = FALSE)

# Convert to treedata object for ggtree
tree_data_object <- tidytree::as.treedata(tree_with_traits)

# Create diagnostic plot showing node numbers and family colors
diagnostic_tree <- ggtree(tree_data_object,
                          layout = "fan",
                          open.angle = 15,
                          size = 2) +
  geom_text2(aes(label = node), hjust = -0.5, vjust = -0.5, size = 6) +
  aes(color = taxa) +
  color_scale

diagnostic_tree

# Save diagnostic tree
ggsave(file.path(phylo_distribution_dir, "diagnostic_tree.png"), diagnostic_tree, device = "png", width = 15, height = 15, dpi = "retina")

# If branch color trait is present, add it to the tree plot
if (isTRUE(has.branch)) {
  capitalized_branch_trait <- tools::toTitleCase(gsub("_", " ", branch_trait))
  # Create base tree with BR gradient
  tree_plot_step1 <- ggtree(tree_data_object, aes(color = BR),
                                  layout="fan",
                                  open.angle=15, 
                                  size=2) +
    scale_color_gradient(
      name = capitalized_branch_trait, 
      low = "skyblue", high = "salmon3",     
                        guide = guide_colorbar(order = 3)) +  # BR last
    new_scale_color()
} else {
  # Add trait bars with gradient
  tree_plot_step1 <- ggtree(tree_data_object,
                                  layout="fan",
                                  open.angle=15, 
                                  size=2)
}  

  tree_plot_step1 <- tree_plot_step1 +
  # Trait bars
  geom_fruit(
    geom = geom_col,
    mapping = aes(y = species, x = trait_sum_plot, fill = trait_fill, width = 0.5),
    alpha = 0.5,  # Set transparency for lighter appearance
    show.legend = TRUE,
    pwidth = 0.75,
    color = "black",  # Add black contour
    size = 0.7,
    axis.params = list(
      axis = 'x',
      text.size = 8,
      nbreak = 2,
      text.angle = 270,
      vjust = 0.5,
      hjust = 0,
      limits = c(0, 40)
    ),
    grid.params = list()
    ) +
  scale_fill_gradient2(
    name = capitalized_trait, 
    low = "white", 
    high = "darkseagreen4",  # Different gradient color for distinction
    guide = guide_colorbar(order = 1),
    aesthetics = "fill"
  ) +
  new_scale_fill()

  # If secondary trait is present, add secondary trait bars
if (isTRUE(has.secondary)) {
  capitalized_secondary_trait <- tools::toTitleCase(gsub("_", " ", secondary_trait))

  tree_plot_step1 <- tree_plot_step1 +
    geom_fruit(
      geom = geom_col,
      offset = -0.75,
      mapping = aes(y = species, x = secondary_sum_plot, fill = secondary_fill, width = 0.5),
      alpha = 0.5,  # Set transparency for lighter appearance
      show.legend = TRUE,
      pwidth = 0.75,
      color = "black",  # Add black contour
      size = 0.7,
      axis.params = list(
        axis = 'x',
        text.size = 0,
        nbreak = 1,
        text.angle = 270,
        vjust = 0.5,
        hjust = 0,
        limits = c(0, 20)
      ),
      grid.params = list()
    ) +
    scale_fill_gradient2(
      name = capitalized_secondary_trait, 
      low = "white", 
      high = "salmon3",  # Different gradient color for distinction
      guide = guide_colorbar(order = 2),
      aesthetics = "fill"
    ) +
    new_scale_fill()
}

tree_plot_step1

# Add taxa membership indicator bars
tree_plot_step2 <- tree_plot_step1 +
  geom_fruit(geom = geom_col, 
             mapping = aes(y = species, x = 1, fill = taxa),
             pwidth = 0.1, color = "black", linewidth = 0.5, offset = 0.2) +
  scale_fill_manual(values = palette_values, breaks = 0) +
  new_scale_fill() +
  theme_tree() +
  theme(panel.background = element_rect(fill = "transparent", colour = NA),  
        plot.background = element_rect(fill = "transparent", colour = NA),
        legend.position = "none",
        plot.title = element_text(size = 17, margin = margin(t = 0, r = 0, b = -1.25, l = 0, unit = "cm")),
        plot.subtitle = element_text(size = 15, margin = margin(t = 0, r = 0, b = -1.5, l = 0, unit = "cm"))
  )

tree_plot_step2

# Add n labels (if applicable)
if(isTRUE(has.n)){
  tree_plot_step3 <- tree_plot_step2 +
    geom_text(aes(label = n_sum), nudge_x = 7.5, fontface = "bold", size = 6, vjust = 0.5)
} else {
  tree_plot_step3 <- tree_plot_step2
}

# Add asterisks for nulled traits
tree_plot_step3 <- tree_plot_step3 +
  geom_text(aes(label = trait_asterisk),
            nudge_x = 6, nudge_y = 0.15,
            color = "darkseagreen4",
            fontface = "bold",
            size = 7,
            vjust = 0.5)

if (isTRUE(has.secondary)) {
  tree_plot_step3 <- tree_plot_step3 +
    geom_text(aes(label = secondary_asterisk),
              nudge_x = 6, nudge_y = -0.15,
              color = "salmon3",
              fontface = "bold",
              size = 7,
              vjust = 0.5)
}

tree_plot_step3

```
```{r visual_distribution_final, fig.height=15, fig.width=17, dev="png", dpi=320, message=TRUE, warning=TRUE}

# Finalize tree with taxon labels and phylopic images
# Build taxon to tip mapping
tip_df <- find_taxon_mrca(pruned_tree, tree_with_traits)

# Get phylopic data
tip_df <- tip_df %>%
  rowwise() %>%  # Apply function row by row
  mutate(phylopic_UUID = rphylopic::get_uuid(name = taxa, n = 1))

# Save for debug
write.csv(tip_df, file.path(phylo_distribution_dir, "taxon_node_mapping.csv"), row.names = FALSE)

# Add family labels and phylopic images
final_tree_plot <- tree_plot_step3 +
  geom_cladelab(data = tip_df,
                mapping = aes(
                  node = mrca_node,
                  label = taxa,
                  image = phylopic_UUID,
                  color = taxa),
                geom="phylopic",
                barsize = NA,
                offset = 13,
                imagesize = 0.05,
                alpha = 0.75) +
  scale_color_manual(values = palette_values, breaks = 0) +
  geom_cladelab(data = tip_df,
                mapping = aes(
                  node = mrca_node,
                  label = taxa),
                show.legend = FALSE,
                          color = "black",
                angle = "auto",
                horizontal = TRUE,
                offset = 10.5,
                barsize = NA,
                fontsize = 8.5,
                fontface = "bold") +
  theme_tree() +
  theme(panel.background = element_rect(fill = "transparent", colour = NA),  
        plot.background = element_rect(fill = "transparent", colour = NA),
        legend.position = "right",
        legend.spacing.y = unit(1.5, 'cm'),
        legend.title = element_text(
          size = 15, face = "bold", 
          margin = margin(b = 15)),
        legend.key.size = unit(1, 'cm'),
        legend.text = element_text(size = 13),
        plot.title = element_text(size = 17, margin = margin(t = 0, r = 0, b = -1.25, l = 0, unit = "cm")),
        plot.subtitle = element_text(size = 15, margin = margin(t = 0, r = 0, b = -1.5, l = 0, unit = "cm"))
  ) +
            # Add caption for asterisks
  labs(caption = "\"*\" indicates that species was removed for this trait as part of the data pruning process\n(following color conventions)") +
  theme(plot.caption = element_text(size = 15, hjust = 0, face = "italic", margin = margin(b = 10)))

final_tree_plot

# Save progressive tree plots
ggsave(file.path(phylo_distribution_dir, "tree_with_trait_bars.png"), tree_plot_step1, device = "png", width = 15, height = 15, dpi = "retina")
ggsave(file.path(phylo_distribution_dir, "tree_with_taxa_bars.png"), tree_plot_step2, device = "png", width = 15, height = 15, dpi = "retina")
if(isTRUE(has.n)){
  ggsave(file.path(phylo_distribution_dir, "tree_with_n_labels.png"), tree_plot_step3, device = "png", width = 15, height = 15, dpi = "retina")
}
ggsave(file.path(phylo_distribution_dir, "final_tree_plot.png"), final_tree_plot, device = "png", width = 17, height = 15, dpi = "retina")

```

## Session Information

```{r debug_dump, results='asis'}

if (length(phylo_debug_log) > 0) {
  cat("### Debug log\n")
  cat(paste0("[DEBUG] ", phylo_debug_log, "\n"))
}

```

```{r session_info}
sessionInfo()
```
