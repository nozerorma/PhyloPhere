---
title: "Exploring Phenotypic Traits in Primate Neoplasia"
author: "Miguel Ramon"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

# Phenotype Exploration
This script explores phenotypic traits related to neoplasia in primates for the Primates' Neoplasia Project. It visualizes trait distributions, phylogenetic patterns, and correlations, focusing on malignancy and neoplasia prevalence, body mass, and longevity. The script includes contrast plots, phylogenetic trees, and phylogenetic generalized least squares (PGLS) analyses to assess trait relationships.


## Setup and Directory Configuration

This section configures the working environment, sets directories, and loads necessary functions and libraries.

```{r setup, message=FALSE, warning=FALSE}

# Suppress warnings and messages in output
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
# Set the root directory for the project
knitr::opts_knit$set(root.dir = "/home/miguel/IBE-UPF/PhD/NEOPLASY_PRIMATES")
# Display current working directory
getwd()
# Set seed for reproducibility
set.seed(1998)

```

```{r dirdef, message=FALSE, warning=FALSE}

# Define working, data, and results directories
workingDir <- getwd()
dataDir <- file.path(workingDir, "Data")
resultsDir <- file.path(workingDir, "Malignancy_Primates/Out")

# Load libraries, common functions, primate-specific functions and objects
source(file.path(workingDir, "Malignancy_Primates/Scripts/functions/libraries.R"))
source(file.path(workingDir, "Malignancy_Primates/Scripts/functions/commons.R"))
source(file.path(workingDir, "Malignancy_Primates/Scripts/functions/primate_functions.R"))
source(file.path(workingDir, "Malignancy_Primates/Scripts/functions/primate_objects.R"))

# Note that all variables may be changed from COMMONS and PRIMATE_OBJECTS scripts.

```

## 1. Cancer Trait Data Import
This section imports processed cancer-related trait data for primates, including longevity information from a previous pipeline.

```{r trait_import}

# 1. TRAIT IMPORT  ------------------------------------------------------
# Load processed cancer traits data with longevity quotient (LQ)
cancer_traits_processed <- read.csv(file.path(trait_dir, "cancer_traits_processed-LQ.csv"))

# Excerpt of the cancer traits data
head(cancer_traits_processed)

# Contradictory species from ACE paper
contradictory.f <- file.path(resultsDir, "1.Data-exploration/5.Data-curation_ZIMS-ACE/Compared_data_ZIMS-ACE.csv")
contradictory <- read.csv(contradictory.f)

# Separate malignant_prevalence* columns from neoplasia_prevalence* columns
contradictory_neoplasia <- contradictory %>%
  select(species, contains("neoplasia_label")) %>%
  # Drop rows with NA
  drop_na() %>%
  # Drop rows where value is INTERMEDIATE
  filter(.[[2]] != "INTERMEDIATE" & .[[3]] != "INTERMEDIATE") %>%
  # Check if column 2 and column 3 are contradictory
  filter(.[[2]] != .[[3]]) %>%
  pull(species)

contradictory_malignant <- contradictory %>%
  select(species, contains("malignant_label")) %>%
  # Drop rows with NA
  drop_na() %>%
  # Drop rows where value is INTERMEDIATE
  filter(.[[2]] != "INTERMEDIATE" & .[[3]] != "INTERMEDIATE") %>%
  # Check if column 2 and column 3 are contradictory
  filter(.[[2]] != .[[3]]) %>%
  pull(species)

# Remove contradictory species from cancer traits processed
cancer_traits_processed <- cancer_traits_processed %>%
  # For species with contradictory labels, set prevalences to NA
  mutate(
    neoplasia_prevalence = if_else(species %in% contradictory_neoplasia, NA_real_, neoplasia_prevalence),
    malignant_prevalence = if_else(species %in% contradictory_malignant, NA_real_, malignant_prevalence)
  )

```

## 2. Load Melted Trait Data
This section loads pre-processed trait data in a long (melted) format and adds common names for species.

```{r, stat_visualization, fig.width=10, fig.height=5, dev="png"}

# 2. LOAD MELTED TRAIT DATA  ------------------------------------------------------
# Load melted traits data
melted_traits <- read.csv(file.path(trait_dir, "melted_traits.csv"))

# Excerpt of the melted traits data
head(melted_traits)

```

# 3. Contrast Plots
This section generates contrast plots to visualize malignant prevalence across primate families, highlighting extreme values and outliers.

```{r phenoplot, fig.height=10, fig.width=15, message=FALSE, warning=FALSE, dev='png'}

createDir(file.path(resultsDir, "1.Data-exploration/6.Post-curation/2.Extreme_plots"))

# 3. CONTRAST PLOTS  ------------------------------------------------------
# Filter necropsy counts for easy recording
necropsy_melt <- melted_traits %>%
  dplyr::filter(trait == "adult_necropsy_count") %>%
  dplyr::rename(necropsy_counts = value) %>%
  dplyr::mutate(necropsy_counts = as.numeric(necropsy_counts)) %>%
  dplyr::ungroup() %>%
  dplyr::select(species, necropsy_counts)

# Merge necropsy counts with melted traits
melt_new <- merge(melted_traits, necropsy_melt, by = "species", all.x = TRUE, all.y = FALSE)

# Calculate global and family-level labels and outliers
melt_new2 <- melt_new %>%
  dplyr::group_by(family, trait) %>%
  dplyr::mutate(
    z_score_fam = (value - mean(value, na.rm = TRUE)) / sd(value, na.rm = TRUE),
    family_label = dplyr::case_when(
      value < quantile(value, 0.25, na.rm = TRUE) & value < median(value, na.rm = TRUE) ~ "low_extreme",
      value > quantile(value, 0.75, na.rm = TRUE) & value > median(value, na.rm = TRUE) ~ "high_extreme",
      value >= quantile(value, 0.25, na.rm = TRUE) & value < quantile(value, 0.5, na.rm = TRUE) ~ "mid_low_extreme",
      value >= quantile(value, 0.5, na.rm = TRUE) & value <= quantile(value, 0.75, na.rm = TRUE) ~ "mid_high_extreme"
    )
  ) %>%
  dplyr::ungroup() %>%
  # Contradictory species are labeled as NA
  dplyr::mutate(
    family_label = ifelse(species %in% contradictory_neoplasia & trait == "neoplasia_prevalence", NA, family_label),
    family_label = ifelse(species %in% contradictory_malignant & trait == "malignant_prevalence", NA, family_label),
    global_label = ifelse(species %in% contradictory_neoplasia & trait == "neoplasia_prevalence", NA, global_label),
    global_label = ifelse(species %in% contradictory_malignant & trait == "malignant_prevalence", NA, global_label)
  )

# Function to generate contrast plots
gen_contrast_g <- function(contrast_t, my_trait, family_plot) {
  # Ensure species order matches phylogeny
  ordered_species <- pruned_tree$tip.label
  contrast_t$species <- factor(contrast_t$species, levels = ordered_species)
  
  # Prepare data based on global or family-level categorization
  if (family_plot == 1) {
    contrast_t <- contrast_t %>%
      dplyr::group_by(species) %>%
      dplyr::arrange(family, .by_group = TRUE) %>%
      dplyr::filter(trait == my_trait) %>%
      dplyr::mutate(
        Value = value,
        Category = global_label,
        Outlier = outlier
      ) %>%
      dplyr::select(family, species, necropsy_counts, common_name, Value, Category, Outlier, median, median_fam) %>%
      dplyr::rename(Family = family, Species = species)
  } else {
    contrast_t <- contrast_t %>%
      dplyr::group_by(species) %>%
      dplyr::arrange(family, .by_group = TRUE) %>%
      dplyr::filter(trait == my_trait) %>%
      dplyr::mutate(
        Value = value,
        Category = family_label,
        Outlier = outlier
      ) %>%
      dplyr::select(family, species, necropsy_counts, common_name, Value, Category, Outlier, median, median_fam) %>%
      dplyr::rename(Family = family, Species = species)
  }
  
  # Replace NA categories with an explicit level so shapes + legends work
  contrast_t <- contrast_t %>%
    mutate(
      Category = tidyr::replace_na(as.character(Category), "missing"),
      Category = factor(Category, levels = c("low_extreme", "mid_low_extreme", "mid_high_extreme", "high_extreme", "missing"))
    )
  
  # Define ordered families for plotting
  ordered_families <- unique(contrast_t$Family)
  
  # Calculate median value for reference line (percent)
  median_value <- median(contrast_t$Value, na.rm = TRUE) * 100
  
  # Prepare shape mapping including explicit value for 'missing'
  shape_values <- c(
    "low_extreme"      = 15,  # solid square
    "mid_low_extreme"  = 1,   # hollow circle
    "mid_high_extreme" = 1,   # hollow circle
    "high_extreme"     = 17,  # solid triangle
    "missing"          = 21   # filled circle with border (works well with fill)
  )
  
  # If primate_family_colors is a named vector keyed by family, add a 'missing' color
  color_values <- c(primate_family_colors, missing = "gray50")
  fill_values  <- c(primate_family_colors, missing = "gray80")
  
  # Build plot
  graph <- ggplot(data = contrast_t, aes(x = Value * 100, y = Family)) +
    scale_y_discrete(limits = ordered_families) +
    
    # mid extremes: hollow points (shape controlled by Category)
    geom_point(
      data = subset(contrast_t, Category %in% c("mid_low_extreme", "mid_high_extreme")),
      aes(shape = Category, color = Family), size = 5, stroke = 1.2
    ) +
    
    # extreme points: solid shapes, use fill as well
    geom_point(
      data = subset(contrast_t, Category %in% c("low_extreme", "high_extreme")),
      aes(shape = Category, color = Family, fill = Family), size = 5, stroke = 1.2
    ) +
    
    # missing / NA category: draw as gray points (constant aesthetic, not mapped)
    geom_point(
      data = subset(contrast_t, Category == "missing"),
      aes(shape = Category), size = 5, stroke = 1.2,
      color = "gray50", fill = "gray80"
    ) +
    
    scale_shape_manual(
      name = "Category",
      values = shape_values,
      na.value = 21, # fallback if something slips through
      labels = c(
        "low_extreme"      = "Low extreme",
        "mid_low_extreme"  = "Mid-low extreme",
        "mid_high_extreme" = "Mid-high extreme",
        "high_extreme"     = "High extreme",
        "missing"          = "Contradictory / NA"
      )
    ) +
    
    scale_fill_manual(name = "Family", values = fill_values, na.value = "gray80") +
    scale_color_manual(name = "Family", values = color_values, na.value = "gray50") +
    
    geom_vline(xintercept = median_value, linewidth = 1.5, color = "salmon3", linetype = "longdash", alpha = 0.8) +
    
    stat_summary(
      fun = median, geom = "errorbar",
      aes(xmax = after_stat(x), xmin = after_stat(x)),
      linewidth = 1.5, color = "skyblue4", alpha = 0.8
    ) +
    
    labs(x = "Malignant prevalence (%)", y = "Primate families", shape = "Category", color = "Family", fill = "Family") +
    
    theme_minimal() +
    theme(
      axis.text.y = element_text(size = 15),
      axis.title.x = element_text(size = 15, hjust = 0.5, margin = margin(t = 20, b = 20)),
      axis.title.y = element_text(size = 15, angle = 90, hjust = 0.5, margin = margin(l = 20, r = 20)),
      legend.text = element_text(size = 12),
      legend.position = "right"
    ) +
    
    ggrepel::geom_text_repel(
      data = subset(contrast_t, Category %in% c("low_extreme", "high_extreme")),
      aes(label = Species), size = 5, hjust = 0, vjust = 0, family = "Inter",
      segment.size = 0.3, nudge_x = 0.010, nudge_y = 0.5, max.overlaps = Inf,
      force = 1, direction = "y", max.iter = 10000, label.padding = 20,
      min.segment.length = 0.06, seed = 2000, show.legend = FALSE
    )
  
  return(graph)
}

# Generate and save contrast plots
global_contrast_graph <- gen_contrast_g(melt_new2, "malignant_prevalence", 1)
ggplot2::ggsave(
  file.path(resultsDir, "1.Data-exploration/6.Post-curation/2.Extreme_plots/malignant_prevalence_global_plot.png"),
  global_contrast_graph, device = "png", width = 15, height = 10, dpi = "retina"
)

family_contrast_graph <- gen_contrast_g(melt_new2, "malignant_prevalence", 0)
ggplot2::ggsave(
  file.path(resultsDir, "1.Data-exploration/6.Post-curation/2.Extreme_plots/malignant_prevalence_family_plot.png"),
  family_contrast_graph, device = "png", width = 15, height = 10, dpi = "retina"
)

# Display plots
global_contrast_graph
family_contrast_graph

```

## 4. Trait Distribution (Phylogenetic Tree)
This section generates a phylogenetic tree visualizing the distribution of malignant prevalence using ancestral state reconstruction (ASR). Using CI computation from ASR.

```{r lambda_bm_trait modeling, fig.height = 20, fig.width = 17, dev = 'png', dpi = 320}

# Required packages: ape, phytools, geiger (optional), dplyr, tidyr
# Install if necessary: install.packages(c("ape","phytools","geiger","dplyr","tidyr"))
gen_ast_tree_model <- function(contrast_t, prim_tree, my_trait,
                               verbose = TRUE,
                               plot = TRUE) {
  # --- Packages ---
  for (pkg in c("ape","phytools","dplyr","tidyr","phylolm")) {
    if (!requireNamespace(pkg, quietly = TRUE)) stop(sprintf("Package '%s' required.", pkg))
  }
  library(ape); library(phytools); library(dplyr); library(tidyr); library(phylolm)
  
  # --- Trait vector ---
  tr <- contrast_t[[my_trait]]; names(tr) <- contrast_t$species
  tr <- tr[!is.na(tr) & is.finite(tr)]
  if(length(tr)<3) stop("Need >=3 non-missing species.")
  
  prim_tree <- ape::drop.tip(prim_tree, setdiff(prim_tree$tip.label, names(tr)))
  prim_tree <- ape::reorder.phylo(prim_tree, "cladewise")
  Ntip <- length(prim_tree$tip.label)
  Nnode <- prim_tree$Nnode
  node_indices <- (Ntip+1):(Ntip+Nnode)
  
  # --- Fit BM / lambda ---
  fit_model <- function(tree, trait, model=c("BM","lambda")) {
    model <- match.arg(model)
    df <- data.frame(trait=trait, species=names(trait))
    fit <- phylolm(trait~1, data=df, phy=tree, model=ifelse(model=="BM","BM","lambda"))
    aic <- fit$aic; k <- fit$p
    aicc <- aic + (2*k*(k+1))/(length(trait)-k-1)
    list(lnL=fit$logLik, sigma2=fit$sigma2, lambda=fit$optpar, aicc=aicc, raw=fit)
  }
  
  fit_bm <- fit_model(prim_tree, tr, "BM")
  fit_lambda <- fit_model(prim_tree, tr, "lambda")
  
  delta_aicc <- fit_bm$aicc - fit_lambda$aicc
  chosen_model <- ifelse(fit_lambda$aicc < fit_bm$aicc, "lambda", "BM")
  if(abs(delta_aicc)<2 && !is.null(fit_lambda$lambda) && abs(fit_lambda$lambda-1)<0.05) chosen_model <- "BM"
  
  # --- Rescale tree & ASR ---
  if(chosen_model=="lambda"){
    lambda_hat <- fit_lambda$lambda %||% 1
    sigma2_used <- fit_lambda$sigma2
    rescaled_tree <- phytools::rescale(prim_tree,"lambda",lambda=lambda_hat)
  } else {
    sigma2_used <- fit_bm$sigma2
    rescaled_tree <- phytools::rescale(prim_tree,"BM")
  }
  
  ace_res <- tryCatch(ape::ace(tr, rescaled_tree, type="continuous", method="REML"),
                      error=function(e) ape::ace(tr,rescaled_tree,type="continuous",method="ML"))
  
  node_est <- ace_res$ace
  node_ci <- ace_res$CI95
  tip_est <- tr[rescaled_tree$tip.label]
  
  # --- Node table ---
  node_df <- data.frame(
    node=node_indices,
    estimate=node_est[as.character(node_indices)],
    ci_lower=node_ci[,1],
    ci_upper=node_ci[,2],
    stringsAsFactors=FALSE
  )
  
  # --- Tip table ---
  tip_df <- data.frame(
    tip=rescaled_tree$tip.label,
    estimate=tip_est,
    immediate_parent=NA,
    direction=NA,
    parent_ci_lower=NA,
    parent_ci_upper=NA,
    derived_root=NA,
    derived_sub=NA,
    derived_super=NA,
    root_ci_lower=NA,
    root_ci_upper=NA,
    sub_ci_lower=NA,
    sub_ci_upper=NA,
    super_ci_lower=NA,
    super_ci_upper=NA,
    stringsAsFactors=FALSE
  )
  
  # Parent map
  parent_map <- integer(Ntip+Nnode); parent_map[] <- NA_integer_
  for(j in 1:nrow(rescaled_tree$edge)){
    parent_map[rescaled_tree$edge[j,2]] <- rescaled_tree$edge[j,1]
  }
  
  root <- Ntip + 1
  root_row <- node_df[node_df$node == root,]
  
  # --- Derivedness & parental CIs for diverged tips ---
  for(i in seq_len(Ntip)){
    tip_idx <- i
    tip_val <- tip_df$estimate[i]
    parent_id <- parent_map[tip_idx]
    if(!is.na(parent_id)){
      if(parent_id <= Ntip){
        parent_val <- tip_est[parent_id]
        parent_l <- parent_val
        parent_u <- parent_val
      } else {
        parent_row <- node_df[node_df$node==parent_id,]
        parent_val <- parent_row$estimate
        parent_l <- parent_row$ci_lower
        parent_u <- parent_row$ci_upper
      }
      tip_df$immediate_parent[i] <- (tip_val > parent_u) || (tip_val < parent_l)
      tip_df$direction[i] <- ifelse(tip_val > parent_u,"up",
                                    ifelse(tip_val < parent_l,"down","none"))
      if(tip_df$immediate_parent[i]){
        tip_df$parent_ci_lower[i] <- parent_l
        tip_df$parent_ci_upper[i] <- parent_u
      }
    }
    # Ancestor path
    anc_path <- c()
    cur <- parent_map[tip_idx]
    while(!is.na(cur)) {
      anc_path <- c(anc_path, cur)
      cur <- parent_map[cur]
    }
    # derived_root
    tip_df$derived_root[i] <- (tip_val > root_row$ci_upper) || (tip_val < root_row$ci_lower)
    if(tip_df$derived_root[i]){
      tip_df$root_ci_lower[i] <- root_row$ci_lower
      tip_df$root_ci_upper[i] <- root_row$ci_upper
    }
    # derived_sub
    sub_node <- if(length(anc_path) >= 2) anc_path[length(anc_path)-1] else NA
    if(!is.na(sub_node)){
      sub_row <- node_df[node_df$node == sub_node,]
      tip_df$derived_sub[i] <- (tip_val > sub_row$ci_upper) || (tip_val < sub_row$ci_lower)
      if(tip_df$derived_sub[i]){
        tip_df$sub_ci_lower[i] <- sub_row$ci_lower
        tip_df$sub_ci_upper[i] <- sub_row$ci_upper
      }
    } else {
      tip_df$derived_sub[i] <- FALSE
    }
    
    # derived_super
    super_node <- if(length(anc_path) >= 3) anc_path[length(anc_path)-2] else NA
    if(!is.na(super_node)){
      super_row <- node_df[node_df$node == super_node,]
      tip_df$derived_super[i] <- (tip_val > super_row$ci_upper) || (tip_val < super_row$ci_lower)
      if(tip_df$derived_super[i]){
        tip_df$super_ci_lower[i] <- super_row$ci_lower
        tip_df$super_ci_upper[i] <- super_row$ci_upper
      }
    } else {
      tip_df$derived_super[i] <- FALSE
    }
  }
  
  # --- Identify partition nodes for plotting ---
  suborder_nodes <- rescaled_tree$edge[rescaled_tree$edge[,1] == root, 2]
  superfamily_nodes <- c()
  for(sub in suborder_nodes){
    children <- rescaled_tree$edge[rescaled_tree$edge[,1] == sub, 2]
    superfamily_nodes <- c(superfamily_nodes, children)
  }
  partition_nodes <- c(root, suborder_nodes, superfamily_nodes)
  
  # --- Plot ---
  if(plot){
    cont_obj <- phytools::contMap(rescaled_tree, tr, plot=FALSE)
    cont_obj <- phytools::setMap(cont_obj, colors=colorRampPalette(c("white","salmon3"))(100))
    h <- max(phytools::nodeHeights(cont_obj$tree))

    par(mar=c(5,5,10,7), oma=c(0,0,2,0)) # Increased top margin and added outer margin

    plot(cont_obj, fsize=1.8, lwd=6, res=320, legend=FALSE,
        xlim=c(-0.2*h, 2*h),
        cex.main=2.5)

    lwd_bar <- 10
    
    phytools::add.color.bar(
      Ntip - 1, 
      cont_obj$cols, 
      title = paste0(my_trait, " (", chosen_model, " - ATR Distribution)"),
      subtitle = "", 
      lims=NULL,
      lwd=lwd_bar, 
      direction="upwards",
      x=-0.2*h, 
      y=1,
      prompt=FALSE, 
      fsize=1.5
    )
    
    # Add ticks and labels to color bar
    tick_x <- -0.2*h + lwd_bar / 20
    lines(x = rep(tick_x, 2), y = c(1, Ntip))
    nticks <- 10
    
    Y <- seq(1, Ntip, length.out = nticks)
    X <- cbind(rep(tick_x, nticks), rep(tick_x + 0.02*h, nticks))
    for (i in 1:length(Y)) lines(X[i, ], Y = c(Y[i], Y[i]))
    ticks <- seq(cont_obj$lims[1], cont_obj$lims[2], length.out = nticks)
    text(x = X[, 2], y = Y, labels = round(ticks, 3), pos = 4, cex = 1.5)
    
    # Get plot positions
    pp <- get("last_plot.phylo", envir = .PlotPhyloEnv)
    
    # Add annotations for partition nodes
    for(node in partition_nodes){
      if(node %in% node_df$node){
        node_row <- node_df[node_df$node == node,]
        label <- sprintf("%.2f(%.2f-%.2f)", node_row$estimate, node_row$ci_lower, node_row$ci_upper)
        x_pos <- pp$xx[node]
        y_pos <- pp$yy[node]
        text(x = x_pos + 0.02 * h, y = y_pos, labels = label, pos = 4, cex = 1.0, col = "black")
      }
    }
      
    for(i in seq_len(Ntip)){
      tip_pos <- i
      has_derived <- tip_df$derived_root[i] | tip_df$derived_sub[i] | tip_df$derived_super[i]
      has_symbol <- tip_df$immediate_parent[i] | has_derived
      
      if(has_symbol){
        ape::tiplabels(text=sprintf("%.2f", tip_df$estimate[i]), tip=tip_pos, frame="none", cex=1.5, offset=40)
        segments(x0 = h, y0 = tip_pos-0.4, x1 = h + 90, y1 = tip_pos-0.4, col = "gray50", lty = 2)
      }
      
      # Tip symbol for immediate
      if(tip_df$immediate_parent[i]){
        pch_val <- ifelse(tip_df$direction[i]=="up",24,25)
        bg_val <- ifelse(tip_df$direction[i]=="up","salmon3","skyblue3")
        ape::tiplabels(pch=pch_val,bg=bg_val,tip=tip_pos,cex=2,offset=58)
        # Parent CI numerically
        ape::tiplabels(text=sprintf("(%.2f-%.2f)", tip_df$parent_ci_lower[i], tip_df$parent_ci_upper[i]),
                       tip=tip_pos, frame="none", cex=1.5, offset=48, col="gray30")
      }
      
      # Derivation symbols
      offset_base <- ifelse(tip_df$immediate_parent[i], 64, 58)
      if(tip_df$derived_root[i]){
        ape::tiplabels(pch=22, bg="forestgreen", tip=tip_pos, cex=2, offset=offset_base)
        # ape::tiplabels(text=sprintf("(%.2f-%.2f)", tip_df$root_ci_lower[i], tip_df$root_ci_upper[i]),
        #                tip=tip_pos, frame="none", cex=1.2, offset=offset_base + 4, col="gray30")
        offset_base <- offset_base + 14
      }
      if(tip_df$derived_sub[i]){
        ape::tiplabels(pch=23, bg="forestgreen", tip=tip_pos, cex=2, offset=offset_base)
        # ape::tiplabels(text=sprintf("(%.2f-%.2f)", tip_df$sub_ci_lower[i], tip_df$sub_ci_upper[i]),
        #                tip=tip_pos, frame="none", cex=1.2, offset=offset_base + 4, col="gray30")
        offset_base <- offset_base + 14
      }
      if(tip_df$derived_super[i]){
        ape::tiplabels(pch=21, bg="forestgreen", tip=tip_pos, cex=2, offset=offset_base)
        # ape::tiplabels(text=sprintf("(%.2f-%.2f)", tip_df$super_ci_lower[i], tip_df$super_ci_upper[i]),
        #                tip=tip_pos, frame="none", cex=1.2, offset=offset_base + 4, col="gray30")
        offset_base <- offset_base + 14
      }
    }
    
    mtext("Symbols: ▲ Tip Up from parent, ▼ Tip Down from parent, ■ Derived from root, ♦ from suborder, ○ from super-family/parvorder;\nColor bar shows trait values as per ATR. Tip estimates shown for symbolized tips; CIs from immediate parent or respective level next to symbols.",
      side=3, line=-2, cex=1.2, adj=0.5)
    
  }
  
  # --- Return ---
  list(
    chosen_model=chosen_model,
    node_table=node_df,
    tip_table=tip_df,
    sigma2_used=sigma2_used,
    ace=ace_res,
    rescaled_tree=rescaled_tree
  )
}

# Generate ASR tree for malignant prevalence
ast_tree <- list()
trait_names <- list("malignant_prevalence" = "malignant_prevalence", "neoplasia_prevalence" = "neoplasia_prevalence")

# Save the tree
plotDir <- file.path(resultsDir, "1.Data-exploration/6.Post-curation/3.Phylogenetic_distribution/ASR")
createDir(plotDir)
  
for (trait in trait_names) {
  png(
    filename = file.path(plotDir, paste0(trait, "-tree.png")),
    width = 17, height = 20, res = 320, bg = "white", units = "in"
  )
  ast_tree[[trait]] <- gen_ast_tree_model(cancer_traits_processed, primate_tree, trait)
  dev.off()
  
  gen_ast_tree_model(cancer_traits_processed, primate_tree, trait)
}

```

##### Using Permulations to compute the CIs (empirical CIs)
```{r lambda_bm_trait2 modeling, fig.height = 20, fig.width = 17, dev = 'png', dpi = 320}

# Required packages: ape, phytools, geiger (optional), dplyr, tidyr
# Install if necessary: install.packages(c("ape","phytools","geiger","dplyr","tidyr"))
gen_ast_tree_model <- function(contrast_t, prim_tree, my_trait,
                               nsim = 10000,           # bootstrap replicates
                               alpha = 0.05,         # CI level
                               test_ou = FALSE,      # not used in this version; keep FALSE to avoid complexity
                               verbose = TRUE,
                               plot = TRUE) {
  # --- Packages ---
  for (pkg in c("ape","phytools","dplyr","tidyr","phylolm")) {
    if (!requireNamespace(pkg, quietly = TRUE)) stop(sprintf("Package '%s' required.", pkg))
  }
  library(ape); library(phytools); library(dplyr); library(tidyr); library(phylolm)
  
  # --- Trait vector ---
  tr <- contrast_t[[my_trait]]; names(tr) <- contrast_t$species
  tr <- tr[!is.na(tr) & is.finite(tr)]
  if(length(tr)<3) stop("Need >=3 non-missing species.")
  
  prim_tree <- ape::drop.tip(prim_tree, setdiff(prim_tree$tip.label, names(tr)))
  prim_tree <- ape::reorder.phylo(prim_tree, "cladewise")
  Ntip <- length(prim_tree$tip.label)
  Nnode <- prim_tree$Nnode
  node_indices <- (Ntip+1):(Ntip+Nnode)
  
  # --- Fit BM / lambda ---
  fit_model <- function(tree, trait, model=c("BM","lambda")) {
    model <- match.arg(model)
    df <- data.frame(trait=trait, species=names(trait))
    fit <- phylolm(trait~1, data=df, phy=tree, model=ifelse(model=="BM","BM","lambda"))
    aic <- fit$aic; k <- fit$p
    aicc <- aic + (2*k*(k+1))/(length(trait)-k-1)
    list(lnL=fit$logLik, sigma2=fit$sigma2, lambda=fit$optpar, aicc=aicc, raw=fit)
  }
  
  fit_bm <- fit_model(prim_tree, tr, "BM")
  fit_lambda <- fit_model(prim_tree, tr, "lambda")
  
  delta_aicc <- fit_bm$aicc - fit_lambda$aicc
  chosen_model <- ifelse(fit_lambda$aicc < fit_bm$aicc, "lambda", "BM")
  if(abs(delta_aicc)<2 && !is.null(fit_lambda$lambda) && abs(fit_lambda$lambda-1)<0.05) chosen_model <- "BM"
  
  # --- Rescale tree & ASR ---
  if(chosen_model=="lambda"){
    lambda_hat <- fit_lambda$lambda %||% 1
    sigma2_used <- fit_lambda$sigma2
    rescaled_tree <- phytools::rescale(prim_tree,"lambda",lambda=lambda_hat)
  } else {
    sigma2_used <- fit_bm$sigma2
    rescaled_tree <- phytools::rescale(prim_tree,"BM")
  }
  
  # --- Compute empirical CIs by parametric bootstrap under chosen model ---
  p_lower <- alpha/2; p_upper <- 1 - alpha/2
  sim_cols <- c(rescaled_tree$tip.label, paste0("node_", node_indices))
  sims_mat <- matrix(NA_real_, nrow = nsim, ncol = length(sim_cols), dimnames = list(NULL, sim_cols))
  # Use phytools::fastBM to simulate BM on rescaled_tree
  root_val <- mean(tr, na.rm = TRUE)
  if (verbose) message(sprintf("Simulating %d datasets under chosen model (%s) with sigma2=%.5g and root=%.5g", nsim, chosen_model, sigma2_used, root_val))
  for (i in seq_len(nsim)) {
    simtrait <- phytools::fastBM(rescaled_tree, sig2 = sigma2_used, a = root_val)
    anc <- phytools::fastAnc(rescaled_tree, simtrait, vars = FALSE, CI = FALSE)
    sims_mat[i, rescaled_tree$tip.label] <- simtrait[rescaled_tree$tip.label]
    sims_mat[i, paste0("node_", node_indices)] <- anc[as.character(node_indices)]
  }
  # Empirical CIs
  ci_lower <- apply(sims_mat, 2, quantile, probs = p_lower, na.rm = TRUE)
  ci_upper <- apply(sims_mat, 2, quantile, probs = p_upper, na.rm = TRUE)
  # Point estimates: for nodes use ape::ace on rescaled_tree, for tips use observed tr
  ace_res <- tryCatch(ape::ace(x = tr, phy = rescaled_tree, type = "continuous", method = "REML"),
                      error = function(e) tryCatch(ape::ace(x = tr, phy = rescaled_tree, type = "continuous", method = "ML"),
                                                   error = function(e2) stop("ace failed on rescaled tree.")))
  node_est <- ace_res$ace
  tip_est <- tr[rescaled_tree$tip.label]
  
  node_df <- data.frame(
    node = node_indices,
    estimate = as.numeric(node_est[as.character(node_indices)]),
    ci_lower = as.numeric(ci_lower[paste0("node_", node_indices)]),
    ci_upper = as.numeric(ci_upper[paste0("node_", node_indices)]),
    stringsAsFactors = FALSE
  )
  tip_df <- data.frame(
    tip = rescaled_tree$tip.label,
    estimate = as.numeric(tip_est[rescaled_tree$tip.label]),
    ci_lower = as.numeric(ci_lower[rescaled_tree$tip.label]),
    ci_upper = as.numeric(ci_upper[rescaled_tree$tip.label]),
    immediate_parent = NA,
    direction = NA,
    parent_ci_lower = NA,
    parent_ci_upper = NA,
    derived_root=NA,
    derived_sub=NA,
    derived_super=NA,
    root_ci_lower=NA,
    root_ci_upper=NA,
    sub_ci_lower=NA,
    sub_ci_upper=NA,
    super_ci_lower=NA,
    super_ci_upper=NA,
    stringsAsFactors = FALSE
  )
  
  # --- Derivedness tests: immediate-parent and cumulative-ancestors ---
  # Build parent map
  parent_map <- integer(Ntip + Nnode); parent_map[] <- NA_integer_
  for (j in seq_len(nrow(rescaled_tree$edge))) {
    p <- rescaled_tree$edge[j,1]; ch <- rescaled_tree$edge[j,2]; parent_map[ch] <- p
  }
  root <- Ntip + 1
  root_row <- node_df[node_df$node == root,]
  
  # Tips
  for (i in seq_len(nrow(tip_df))) {
    this_tip <- tip_df$tip[i]
    this_est <- tip_df$estimate[i]; this_l <- tip_df$ci_lower[i]; this_u <- tip_df$ci_upper[i]
    tip_idx <- which(rescaled_tree$tip.label == this_tip)
    parent_id <- parent_map[tip_idx]
  
    if (!is.na(parent_id)) {
      if (parent_id <= Ntip) {
        parent_l <- tip_df$ci_lower[which(tip_df$tip == rescaled_tree$tip.label[parent_id])]
        parent_u <- tip_df$ci_upper[which(tip_df$tip == rescaled_tree$tip.label[parent_id])]
      } else {
        parent_row <- node_df[node_df$node == parent_id, ]
        parent_l <- parent_row$ci_lower; parent_u <- parent_row$ci_upper
      }
      # Immediate-parent derivedness
      tip_df$immediate_parent[i] <- (this_est > parent_u) || (this_est < parent_l)
      if (this_est > parent_u) tip_df$direction[i] <- "up"
      else if (this_est < parent_l) tip_df$direction[i] <- "down"
      else tip_df$direction[i] <- "none"
      if (tip_df$immediate_parent[i]) {
        tip_df$parent_ci_lower[i] <- parent_l
        tip_df$parent_ci_upper[i] <- parent_u
      }
    }
    # Ancestor path
    anc_path <- c()
    cur <- parent_map[tip_idx]
    while(!is.na(cur)) {
      anc_path <- c(anc_path, cur)
      cur <- parent_map[cur]
    }
    # derived_root
    tip_df$derived_root[i] <- (this_est > root_row$ci_upper) || (this_est < root_row$ci_lower)
    if(tip_df$derived_root[i]){
      tip_df$root_ci_lower[i] <- root_row$ci_lower
      tip_df$root_ci_upper[i] <- root_row$ci_upper
    }
    # derived_sub
    sub_node <- if(length(anc_path) >= 2) anc_path[length(anc_path)-1] else NA
    if(!is.na(sub_node)){
      sub_row <- node_df[node_df$node == sub_node,]
      tip_df$derived_sub[i] <- (this_est > sub_row$ci_upper) || (this_est < sub_row$ci_lower)
      if(tip_df$derived_sub[i]){
        tip_df$sub_ci_lower[i] <- sub_row$ci_lower
        tip_df$sub_ci_upper[i] <- sub_row$ci_upper
      }
    } else {
      tip_df$derived_sub[i] <- FALSE
    }
    
    # derived_super
    super_node <- if(length(anc_path) >= 3) anc_path[length(anc_path)-2] else NA
    if(!is.na(super_node)){
      super_row <- node_df[node_df$node == super_node,]
      tip_df$derived_super[i] <- (this_est > super_row$ci_upper) || (this_est < super_row$ci_lower)
      if(tip_df$derived_super[i]){
        tip_df$super_ci_lower[i] <- super_row$ci_lower
        tip_df$super_ci_upper[i] <- super_row$ci_upper
      }
    } else {
      tip_df$derived_super[i] <- FALSE
    }
  }

  node_df$immediate_parent <- NA; node_df$direction <- NA
  for (i in seq_len(nrow(node_df))) {
    this_node <- node_df$node[i]
    this_l <- node_df$ci_lower[i]; this_u <- node_df$ci_upper[i]
    parent_id <- parent_map[this_node]
    if (is.na(parent_id)) { node_df$immediate_parent[i] <- NA; node_df$direction[i] <- "none"; next }
    if (parent_id <= Ntip) {
      parent_row <- tip_df[tip_df$tip == rescaled_tree$tip.label[parent_id], ]
      parent_l <- parent_row$ci_lower; parent_u <- parent_row$ci_upper
    } else {
      parent_row <- node_df[node_df$node == parent_id, ]
      parent_l <- parent_row$ci_lower; parent_u <- parent_row$ci_upper
    }
    node_df$immediate_parent[i] <- (node_df$estimate[i] > parent_u) || (node_df$estimate[i] < parent_l)
    if (node_df$estimate[i] > parent_u) node_df$direction[i] <- "up"
    else if (node_df$estimate[i] < parent_l) node_df$direction[i] <- "down"
    else node_df$direction[i] <- "none"
  }
  
  # --- Identify partition nodes for plotting ---
  suborder_nodes <- rescaled_tree$edge[rescaled_tree$edge[,1] == root, 2]
  superfamily_nodes <- c()
  for(sub in suborder_nodes){
    children <- rescaled_tree$edge[rescaled_tree$edge[,1] == sub, 2]
    superfamily_nodes <- c(superfamily_nodes, children)
  }
  partition_nodes <- c(root, suborder_nodes, superfamily_nodes)
  
  # --- Plot ---
  if(plot){
    cont_obj <- phytools::contMap(rescaled_tree, tr, plot=FALSE)
    cont_obj <- phytools::setMap(cont_obj, colors=colorRampPalette(c("white","salmon3"))(100))
    h <- max(phytools::nodeHeights(cont_obj$tree))
    par(mar=c(5,5,12,7), oma=c(0,0,4,0)) # Increased top margin and outer margin further
    plot(cont_obj, fsize=1.8, lwd=6, res=320, legend=FALSE,
         xlim=c(-0.2*h, 2*h),
         cex.main=2.5)
    
    title(main = paste0(my_trait, " - Ancestral Trait Reconstruction"), cex.main = 1.5, line = 8)
    
    lwd_bar <- 10
    
    phytools::add.color.bar(
      Ntip - 1, 
      cont_obj$cols, 
      title = paste0(my_trait, " (", chosen_model, " - ATR Distribution)"),
      subtitle = "",
      lims=NULL,
      lwd=lwd_bar, 
      direction="upwards",
      x=-0.2*h, 
      y=1,
      prompt=FALSE, 
      fsize=1.5
    )
    
    # Add ticks and labels to color bar
    tick_x <- -0.2*h + lwd_bar / 20
    lines(x = rep(tick_x, 2), y = c(1, Ntip))
    nticks <- 10
    
    Y <- seq(1, Ntip, length.out = nticks)
    X <- cbind(rep(tick_x, nticks), rep(tick_x + 0.02*h, nticks))
    for (i in 1:length(Y)) lines(X[i, ], Y = c(Y[i], Y[i]))
    ticks <- seq(cont_obj$lims[1], cont_obj$lims[2], length.out = nticks)
    text(x = X[, 2], y = Y, labels = round(ticks, 3), pos = 4, cex = 1.5)
    
    # Get plot positions
    pp <- get("last_plot.phylo", envir = .PlotPhyloEnv)
    
    # Add annotations for partition nodes
    for(node in partition_nodes){
      if(node %in% node_df$node){
        node_row <- node_df[node_df$node == node,]
        label <- sprintf("%.2f(%.2f-%.2f)", node_row$estimate, node_row$ci_lower, node_row$ci_upper)
        x_pos <- pp$xx[node]
        y_pos <- pp$yy[node]
        text(x = x_pos + 0.02 * h, y = y_pos, labels = label, pos = 4, cex = 1.0, col = "black")
      }
    }
      
    for(i in seq_len(Ntip)){
      tip_pos <- i
      has_derived <- tip_df$derived_root[i] | tip_df$derived_sub[i] | tip_df$derived_super[i]
      has_symbol <- tip_df$immediate_parent[i] | has_derived
      
      if(has_symbol){
        ape::tiplabels(text=sprintf("%.2f", tip_df$estimate[i]), tip=tip_pos, frame="none", cex=1.5, offset=40)
        segments(x0 = h, y0 = tip_pos-0.4, x1 = h + 90, y1 = tip_pos-0.4, col = "gray50", lty = 2)
      }
      
      # Tip symbol for immediate
      if(tip_df$immediate_parent[i]){
        pch_val <- ifelse(tip_df$direction[i]=="up",24,25)
        bg_val <- ifelse(tip_df$direction[i]=="up","salmon3","skyblue3")
        ape::tiplabels(pch=pch_val,bg=bg_val,tip=tip_pos,cex=2,offset=58)
        # Parent CI numerically
        ape::tiplabels(text=sprintf("(%.2f-%.2f)", tip_df$parent_ci_lower[i], tip_df$parent_ci_upper[i]),
                       tip=tip_pos, frame="none", cex=1.5, offset=48, col="gray30")
      }
      
      # Derivation symbols
      offset_base <- ifelse(tip_df$immediate_parent[i], 64, 58)
      if(tip_df$derived_root[i]){
        ape::tiplabels(pch=22, bg="forestgreen", tip=tip_pos, cex=2, offset=offset_base)
        # ape::tiplabels(text=sprintf("(%.2f-%.2f)", tip_df$root_ci_lower[i], tip_df$root_ci_upper[i]),
        #                tip=tip_pos, frame="none", cex=1.2, offset=offset_base + 4, col="gray30")
        offset_base <- offset_base + 14
      }
      if(tip_df$derived_sub[i]){
        ape::tiplabels(pch=23, bg="forestgreen", tip=tip_pos, cex=2, offset=offset_base)
        # ape::tiplabels(text=sprintf("(%.2f-%.2f)", tip_df$sub_ci_lower[i], tip_df$sub_ci_upper[i]),
        #                tip=tip_pos, frame="none", cex=1.2, offset=offset_base + 4, col="gray30")
        offset_base <- offset_base + 14
      }
      if(tip_df$derived_super[i]){
        ape::tiplabels(pch=21, bg="forestgreen", tip=tip_pos, cex=2, offset=offset_base)
        # ape::tiplabels(text=sprintf("(%.2f-%.2f)", tip_df$super_ci_lower[i], tip_df$super_ci_upper[i]),
        #                tip=tip_pos, frame="none", cex=1.2, offset=offset_base + 4, col="gray30")
        offset_base <- offset_base + 14
      }
    }
    
    # Custom time axis under the tree only, starting at root
    time_range <- pretty(c(0, h))
    at_pos <- time_range
    axis(1, at = at_pos, labels = time_range, cex.axis = 1.5)
    graphics::mtext("Time (relative units)", side=1, line=3, cex=2.2)
    
    mtext("Symbols: ▲ Tip Up from parent, ▼ Tip Down from parent, ■ Derived from root, ♦ from suborder, ○ from super-family/parvorder;\nColor bar shows trait values as per ATR. Tip estimates shown for symbolized tips; CIs from immediate parent or respective level next to symbols.",
          side=3, line=-2, cex=1.2, adj=0.5)
    
  }
  
  # --- Return ---
  list(
    chosen_model=chosen_model,
    node_table=node_df,
    tip_table=tip_df,
    sigma2_used=sigma2_used,
    ace=ace_res,
    rescaled_tree=rescaled_tree
  )
}

# Generate ASR tree for malignant prevalence
ast_tree <- list()
trait_names <- list("malignant_prevalence" = "malignant_prevalence", "neoplasia_prevalence" = "neoplasia_prevalence")

# Save the tree
plotDir <- file.path(resultsDir, "1.Data-exploration/6.Post-curation/3.Phylogenetic_distribution/ASR_empirical")
createDir(plotDir)
  
for (trait in trait_names) {
  png(
    filename = file.path(plotDir, paste0(trait, "-tree.png")),
    width = 17, height = 20, res = 320, bg = "white", units = "in"
  )
  ast_tree[[trait]] <- gen_ast_tree_model(cancer_traits_processed, primate_tree, trait)
  dev.off()
  
  gen_ast_tree_model(cancer_traits_processed, primate_tree, trait)
}

```


## 5. Extreme Value Plots
This section generates violin plots to visualize malignant prevalence distributions, highlighting extreme values without removing outliers.

```{r extremes_plots, fig.height=10, fig.width=7, message=FALSE, warning=FALSE, dev='png', dpi = 320}

# 5. EXTREME VALUE PLOTS  ------------------------------------------------------
# Define darkened color palette for plotting
dark_family_palette <- colorspace::darken(primate_family_colors, amount = 0.5)

# Function to generate contrast plots with violin distributions
gen_contrast_g <- function(contrast_t, my_trait, family_plot) {
  # Ensure species order matches phylogeny
  ordered_species <- pruned_tree$tip.label
  contrast_t$species <- factor(contrast_t$species, levels = ordered_species)
  
  # Prepare data based on global or family-level categorization
  if (family_plot == 0) {
    contrast_t <- contrast_t %>%
      dplyr::group_by(species) %>%
      dplyr::arrange(family, .by_group = TRUE) %>%
      dplyr::filter(trait == my_trait) %>%
      dplyr::mutate(Value = value, Category = global_label, Outlier = outlier) %>%
      dplyr::select(family, species, necropsy_counts, common_name, Value, Category, Outlier, median, median_fam) %>%
      dplyr::rename(Family = family, Species = species)
  } else {
    contrast_t <- contrast_t %>%
      dplyr::group_by(species) %>%
      dplyr::arrange(family, .by_group = TRUE) %>%
      dplyr::filter(trait == my_trait) %>%
      dplyr::mutate(Value = value, Category = family_label, Outlier = outlier) %>%
      dplyr::select(family, species, necropsy_counts, common_name, Value, Category, Outlier, median, median_fam) %>%
      dplyr::rename(Family = family, Species = species)
  }
  
  # Define ordered families for plotting
  ordered_families <- c(
    "Lorisidae", "Galagidae", "Indriidae", "Cheirogaleidae", "Lemuridae",
    "Atelidae", "Cebidae", "Aotidae", "Callitrichidae", "Hylobatidae",
    "Hominidae", "Cercopithecidae"
  )
    
  # Replace NA categories with an explicit level so shapes + legends work
  contrast_t <- contrast_t %>%
    mutate(
      Category = tidyr::replace_na(as.character(Category), "missing"),
      Category = factor(Category, levels = c("low_extreme", "mid_low_extreme", "mid_high_extreme", "high_extreme", "missing"))
    )
  
  # Calculate median value for reference line
  median_value <- median(contrast_t$Value, na.rm = TRUE) * 100
  
  # Split data for plotting: non-missing categories vs missing
  ct_nonmissing <- contrast_t %>% filter(Category != "missing")
  ct_missing    <- contrast_t %>% filter(Category == "missing")
  
  # Create violin plot
  graph <- ggplot2::ggplot(data = contrast_t, aes(x = Value * 100, y = Family)) +
    ggplot2::scale_y_discrete(limits = rev(ordered_families)) +
    
    # violin (family fill from primate_family_colors)
    ggplot2::geom_violin(
      aes(fill = Family, alpha = 0.1),
      color = "black", width = 0.5, trim = TRUE, scale = "width"
    ) +
    ggplot2::scale_fill_manual(values = primate_family_colors, na.value = "gray90") +
    
    # start new fill scale for stars (so violin fill and star fill are independent)
    ggnewscale::new_scale_fill() +
    
    # stars for non-missing categories: map starshape -> Category; use family color/fill
    ggstar::geom_star(
      data = ct_nonmissing,
      ggplot2::aes(starshape = Category, color = Family, fill = Family),
      size = 3, position = ggplot2::position_jitter(height = 0.25)
    ) +
    
    # starshape mapping including explicit 'missing' level
    ggstar::scale_starshape_manual(
      values = c(
        "low_extreme"      = 21,  # filled circle
        "mid_low_extreme"  = 15,  # square
        "mid_high_extreme" = 15,  # square
        "high_extreme"     = 29,  # filled triangle
        "missing"          = 27    # hollow circle for missing (but we'll draw missing in separate layer)
      ),
      na.translate = FALSE,
      name = "Category",
      labels = c(
        "low_extreme" = "Low extreme",
        "mid_low_extreme" = "Mid-low extreme",
        "mid_high_extreme" = "Mid-high extreme",
        "high_extreme" = "High extreme",
        "missing" = "Missing / NA"
      )
    ) +
    
    # second star layer: draw missing rows with constant aesthetics (no mapping) so they don't pollute legend
    ggstar::geom_star(
      data = ct_missing,
      ggplot2::aes(starshape = Category),
      size = 3, position = ggplot2::position_jitter(height = 0.25),
      color = "gray50", fill = "gray80"
    ) +
    
    # color / fill scales for family stars (non-missing rows)
    ggplot2::scale_fill_manual(values = dark_family_palette, na.value = "gray90", guide = "none") +
    ggplot2::scale_color_manual(values = dark_family_palette, na.value = "gray50", guide = "none") +
    
    ggplot2::geom_vline(
      aes(xintercept = median_value), linewidth = 1, color = "salmon3", alpha = 0.5
    ) +
    ggplot2::stat_summary(
      fun = median, geom = "errorbar",
      aes(xmax = after_stat(x), xmin = after_stat(x)),
      linewidth = 1.5, color = "black", alpha = 0.6, width = 0.75
    ) +
    ggplot2::labs(x = "Malignant prevalence (%)") +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      axis.text.y = ggplot2::element_text(size = 17, hjust = 0.5, face = "bold"),
      axis.title.x = ggplot2::element_text(size = 17, hjust = 0.5, face = "bold", margin = ggplot2::margin(t = 20, b = 20)),
      axis.title.y = ggplot2::element_blank(),
      legend.text = ggplot2::element_text(size = 15),
      legend.position = "none"
    )
  
  return(graph)
}

# Generate and save violin plot
global_contrast_graph_mp <- gen_contrast_g(melt_new2, "malignant_prevalence", 0)
ggplot2::ggsave(
  file.path(resultsDir, "1.Data-exploration/6.Post-curation/2.Extreme_plots/malignant_prevalence_violin_plot.png"),
  global_contrast_graph_mp, device = "png", width = 7, height = 10, dpi = "retina"
)

# For neoplasia
global_contrast_graph_np <- gen_contrast_g(melt_new2, "neoplasia_prevalence", 0)
ggplot2::ggsave(
  file.path(resultsDir, "1.Data-exploration/6.Post-curation/2.Extreme_plots/neoplasia_prevalence_violin_plot.png"),
  global_contrast_graph_np, device = "png", width = 7, height = 10, dpi = "retina"
)

# Display plot
global_contrast_graph_mp
global_contrast_graph_np

```

## 6. Fan Plot for Family and Cancer Distribution
This section creates a fan-shaped phylogenetic tree with overlaid data on neoplasia and malignant prevalence, family membership, and necropsy counts.

```{r visual_distribution, fig.height = 15, fig.width = 15, dev = 'png', dpi = 320}

# 6. FAN PLOT FOR FAMILY AND CANCER DISTRIBUTION  ------------------------------------------------------
# Prune phy and plot the complete phylogeny in fan shape
big_tree <- ggtree(pruned_tree,
              layout="fan",
              open.angle=15, 
              size=2)

plotDir <- file.path(resultsDir, "1.Data-exploration/6.Post-curation/3.Phylogenetic_distribution")
ggsave(file.path(plotDir, "big_tree.png"), big_tree, device = "png", width = 15, height = 15, dpi = "retina")

ordered_species <- rev(pruned_tree$tip.label)
row.names(cancer_traits_processed) <- cancer_traits_processed$species

# mapping external data to the tree structure
spread_df <- melt_new2 %>%
  spread(trait, value) %>%
  dplyr::rename(label = species) 

# Use LQ instead of LQ

primates_traits2 <- spread_df
primates_traits2 <- primates_traits2 %>%
  dplyr::select(label, family, necropsy_counts, malignant_prevalence, neoplasia_prevalence, LQ) %>%
  mutate(malignant_prevalence = malignant_prevalence * 100) %>%
  mutate(neoplasia_prevalence = neoplasia_prevalence * 100) %>%
  group_by(label, family)  %>%
  summarize(
    malignant_prevalence = sum(malignant_prevalence, na.rm = TRUE),
    neoplasia_prevalence = sum(neoplasia_prevalence, na.rm = TRUE),
    LQ = sum(LQ, na.rm = TRUE),
    .groups = "drop") %>%
  ungroup() %>%
  # Re-add necropsy_counts, join by species cancer_traits
  left_join(cancer_traits_processed %>% dplyr::select(species, adult_necropsy_count), by = c("label" = "species")) %>%
  dplyr::rename(necropsy_count = adult_necropsy_count) %>%
  mutate(LQ = LQ)

# Again, add NA to contradictory species
primates_traits2 <- primates_traits2 %>%
  mutate(
    neoplasia_prevalence = if_else(label %in% contradictory_neoplasia, NA_real_, neoplasia_prevalence),
    malignant_prevalence = if_else(label %in% contradictory_malignant, NA_real_, malignant_prevalence)
  )

primates_traits2 <- primates_traits2 %>%
  mutate(
    neoplasia_is_na = is.na(neoplasia_prevalence),
    malignant_is_na = is.na(malignant_prevalence),
    # Use a small positive value (1) instead of 0 for NAs so bars are visible
    neoplasia_prevalence_plot = ifelse(is.na(neoplasia_prevalence), 1, neoplasia_prevalence),
    malignant_prevalence_plot = ifelse(is.na(malignant_prevalence), 0.5, malignant_prevalence),
    # Create fill values that will map to the gradient or to NA (for gray color)
    neoplasia_fill = ifelse(neoplasia_is_na, NA_real_, neoplasia_prevalence),
    malignant_fill = ifelse(malignant_is_na, NA_real_, malignant_prevalence),
    # Create asterisk labels
    neoplasia_asterisk = ifelse(neoplasia_is_na, "*", ""),
    malignant_asterisk = ifelse(malignant_is_na, "*", "")
  )

# Perform an AST of the LQ trait
LQ_vec <- primates_traits2$LQ
names(LQ_vec) <- primates_traits2$label
LQ_fit <- phytools::fastAnc(pruned_tree, LQ_vec, vars = TRUE, CI = TRUE)

td <- data.frame(node = nodeid(pruned_tree, names(LQ_vec)),
               LQ = LQ_vec)
nd <- data.frame(node = names(LQ_fit$ace), LQ = LQ_fit$ace)
d <- rbind(td, nd)
d$node <- as.numeric(d$node)

primates_tree2 <- treeio::as_tibble(pruned_tree)

primates_tree2 <- full_join(primates_tree2, primates_traits2, by = 'label')
primates_tree2.5 <- full_join(primates_tree2, d, by = 'node') %>%
  mutate(LQ = ifelse(is.na(LQ.y), LQ.x, LQ.y)) %>%
  dplyr::select(-LQ.x, -LQ.y)

# the tbl_tree object is converted to a treedata object
primates_tree3 <- tidytree::as.treedata(primates_tree2.5)

pruned_plot <- ggtree(primates_tree3,
                      layout = "fan",
                      open.angle = 15,
                      size = 2) +
  geom_text2(aes(label = node), hjust = -0.5, vjust = -0.5, size = 6) +
  aes(color = family) +  # Color branches by family
  scale_color_manual(values = primate_family_colors)

pruned_plot

p <- ggtree(primates_tree3, aes(color = LQ),
            layout="fan",
            open.angle=15, 
            size=2) +
            scale_color_gradient(low = "skyblue", high = "salmon3", na.value = "gray90",     
                                 guide = guide_colorbar(order = 3)) +  # LQ last
            new_scale_color()
p

# Add neoplasia data info with gradient and black contour
p1 <- p + 
  # Neoplasia prevalence bars
  geom_fruit(
    geom = geom_col,
    mapping = aes(y = species, x = neoplasia_prevalence_plot, 
                  fill = neoplasia_fill,  # Use the separate fill column
                  width = 0.5),
    alpha = 0.5,
    show.legend = TRUE,
    pwidth = 0.75,
    color = "black",
    size = 0.7,
    axis.params = list(
      axis = 'x',
      text.size = 8,
      nbreak = 2,
      text.angle = 270,
      vjust = 0.5,
      hjust = 0,
      limits = c(0, 40)
    ),
    grid.params = list()
  ) +
  scale_fill_gradient2(
    name = "% Neoplasia Prevalence", 
    low = "white", 
    high = "darkseagreen",
    na.value = "gray90",  # Gray for NA values
    guide = guide_colorbar(order = 2),
    aesthetics = "fill"
  ) +
  new_scale_fill() +
  # Malignant prevalence bars
  geom_fruit(
    geom = geom_col,
    offset = -0.75,
    mapping = aes(y = species, x = malignant_prevalence_plot, 
                  fill = malignant_fill,  # Use the separate fill column
                  width = 0.5),
    show.legend = TRUE,
    pwidth = 0.75,
    alpha = 0.75,
    color = "black",
    size = 0.7,
    axis.params = list(
      axis = 'x',
      text.size = 0,
      nbreak = 1,
      text.angle = 270,
      vjust = 0.5,
      hjust = 0,
      limits = c(0, 20)
  )) +
  scale_fill_gradient2(
    name = "% Malignant Prevalence", 
    low = "white", 
    high = "salmon3", 
    na.value = "gray90",  # Gray for NA values
    guide = guide_colorbar(order = 1),
    aesthetics = "fill"
  ) +
  new_scale_fill()
  

p1

# Add clade information
p2 <- p1 +
    geom_fruit(geom = geom_col, 
               mapping = aes(y = species, x = 1, fill = family, width = 1),
               pwidth = 0.1, color = "black", linewidth = 0.5, offset = 0) +
    scale_fill_manual(values = primate_family_colors, breaks = 0) +
    new_scale_fill() +
    theme_tree() +
    theme(panel.background = element_rect(fill = "transparent", colour = NA),  
      plot.background = element_rect(fill = "transparent", colour = NA),
      legend.position = "none",
      plot.title = element_text(size = 17, margin = margin(t = 0, r = 0, b = -1.25, l = 0, unit = "cm")),
      plot.subtitle = element_text(size = 15, margin = margin(t = 0, r = 0, b = -1.5, l = 0, unit = "cm"))
  )

p2

# Add counts information in an informative way
p3 <- p2 +
  geom_text(aes(label = necropsy_count), nudge_x = 42.5, fontface = "bold", size = 7, vjust = 0.5) +
  # Add green asterisk for neoplasia NA
  geom_text(aes(label = neoplasia_asterisk), 
            nudge_x = 37, nudge_y = 0.15,
            color = "darkseagreen4", 
            fontface = "bold", 
            size = 8, 
            vjust = 0.5) +
  # Add red asterisk for malignant NA
  geom_text(aes(label = malignant_asterisk), 
            nudge_x = 37, nudge_y = -0.15,
            color = "salmon3", 
            fontface = "bold", 
            size = 8, 
            vjust = 0.5)

p3


## This commented bit must only be run once in order to create the family_node_positions.csv file.
## Parent nodes must be manually added to the family_node_positions.csv file. This is why we are reading it directly, as it has already been manually edited.
# Create dataframe with topmost node per family from primates_tree2
# family_node_positions <- primates_tree2 %>%
#   group_by(family) %>%
#   mutate(family_size = n()) %>%
#   mutate(angle = ifelse(family_size > 1, 0, 90)) %>%  # Horizontal if more than 1 species, vertical otherwise
#   filter(parent == min(parent)) %>%
#   dplyr::select(parent, family, family_size, angle) %>%
#   distinct() %>%
#   drop_na()
# 
# Get phylopic data
# family_node_positions <- family_node_positions %>%
#   rowwise() %>%  # Apply function row by row
#   mutate(phylopic_UUID = get_uuid(name = family, n = 1)) %>%
#   mutate(fams = family)
# 
# write.csv(family_node_positions, file.path(family_node_dir, "family_node_positions.csv"), row.names = FALSE)
##

# Read node data and UUID from phylopic
family_node_dir <- file.path(dataDir, "5.Phylogeny/")
family_node_positions <- read.csv(file.path(family_node_dir, "family_node_positions.csv"))

# Separate single and multiple family nodes
single_family_node_positions <- family_node_positions[family_node_positions$family_size == 1, ]
multiple_family_node_positions <- family_node_positions[family_node_positions$family_size > 1, ]


# Now use this to set dynamic label angles in geom_cladelab
# p0 <- ggtree(primates_tree3,
#             layout="fan",
#             open.angle=15, 
#             size=0)

p4 <- p3 +
  geom_cladelab(data = family_node_positions,
      mapping = aes(
        node = parent,
        label = fams,
        image = phylopic_UUID,
        color = fams),  # Use dynamic angles
      geom="phylopic",
      barsize = NA,
      offset = 80,
      imagesize = 0.05,
      alpha = 0.75) +
  scale_color_manual(values = primate_family_colors, breaks = 0) +
  geom_cladelab(data = family_node_positions,
      mapping = aes(
        node = parent,
        label = fams),
      show.legend = FALSE,
      color = "black",  # Black labels
      angle = "auto",
      horizontal = TRUE,
      offset = 55,
      barsize = NA,
      fontsize = 9.5,
      fontface = "bold") +
  theme_tree() +
  theme(panel.background = element_rect(fill = "transparent", colour = NA),  
      plot.background = element_rect(fill = "transparent", colour = NA),
      legend.position = "right",
      legend.spacing.y = unit(1.5, 'cm'),
      legend.title = element_text(
        size = 15, face = "bold", 
        margin = margin(b = 15)),
      legend.key.size = unit(1, 'cm'),
      legend.text = element_text(size = 13),
      plot.title = element_text(size = 17, margin = margin(t = 0, r = 0, b = -1.25, l = 0, unit = "cm")),
      plot.subtitle = element_text(size = 15, margin = margin(t = 0, r = 0, b = -1.5, l = 0, unit = "cm"))
  )

p4

dir <- "1.Data-exploration/6.Post-curation/3.Phylogenetic_distribution"
createDir(file.path(resultsDir, dir))

# Save p1
ggsave(file.path(resultsDir, dir, "neoplasia_prevalence_tree1.png"), p1, device = "png", width = 15, height = 15, dpi = "retina")

# Save p2
ggsave(file.path(resultsDir, dir, "neoplasia_prevalence_tree2.png"), p2, device = "png", width = 15, height = 15, dpi = "retina")

# Save p3
ggsave(file.path(resultsDir, dir, "neoplasia_prevalence_tree3.png"), p3, device = "png", width = 17, height = 17, dpi = "retina")

# Save p4
ggsave(file.path(resultsDir, dir, "neoplasia_prevalence_tree4.png"), p4, device = "png", width = 20, height = 17, dpi = "retina")

```